[{"id":0,"href":"/styleguide/docs/01-overview/","title":"01 Overview","section":"Docs","content":" 概览 # "},{"id":1,"href":"/styleguide/docs/02-guide/","title":"02 Guide","section":"Docs","content":" Go 编程规范 # 风格原则 # 以下几条总体原则总结了如何编写可读的 Go 代码。以下为具有可读性的代码特征，按重要性排序：\n清晰：代码的目的和理由对读者来说是清楚的。 简单：代码以最简洁的方式完成了它的目的。 简约：代码具有很高的信噪比。 可维护：代码可以很容易地维护。 一致：代码与更广泛的谷歌代码库一致。 清晰 # 可读性的核心目标是写出对读者来说很清晰的代码。\n清晰性主要是通过有效的命名、有用的注释和有效的代码组织来实现的。\n清晰性要从读者的角度来看，而不是从代码的作者的角度来看，代码的易读性比易写性更重要。代码的清晰性有两个不同的方面：\n该代码实际上在做什么？ 为什么代码会这么做？ 该代码实际上在做什么 # Go 的设计是可以比较直接地看到代码在做什么。在比较未知的或者读者可能需要先验知识才能理解代码的情况下，我们值得投入时间以使代码的目的对未来的读者更加明确。例如，它可能有助于：\n使用更具描述性的变量名称 添加额外的评论 使用空白与注释来划分代码 将代码重构为独立的函数/方法，使其更加模块化 这里没有一个放之四海而皆准的方法，但在开发 Go 代码时，优先考虑清晰性是很重要的。\n为什么代码会这么做 # 代码的基本原理通常由变量、函数、方法或包的名称充分传达。如果不是这样，添加注释是很重要的。当代码中包含读者可能不熟悉的细节时，“为什么？”就显得尤为重要，例如：\n编程语言中的细微差别，例如，一个闭包将捕获一个循环变量，但闭包在许多行之外 业务逻辑的细微差别，例如，需要区分实际用户和虚假用户的访问控制检查 一个 API 可能需要小心翼翼才能正确使用。例如，由于性能原因，一段代码可能错综复杂，难以理解，或者一连串复杂的数学运算可能以一种意想不到的方式使用类型转换。在这些以及更多的情况下，附带的注释和文档对这些方面进行解释是很重要的，这样未来的维护者就不会犯错，读者也可以理解代码而不需要进行逆向工程。\n同样重要的是，我们要意识到，一些基于清晰性考虑的尝试（如添加额外的注释）实际上会通过增加杂乱无章的内容、重述代码已经说过的内容、与代码相矛盾或增加维护负担以保持注释的最新性来掩盖代码的目的。让代码自己说话（例如，通过代码中的名称本身进行描述），而不是添加多余的注释。通常情况下，注释最好是解释为什么要做某事，而不是解释代码在做什么。\n谷歌的代码库基本上是统一和一致的。通常情况下，那些比较突兀的代码（例如，应用一个不熟悉的模式）是基于充分的理由，通常是为了性能。保持这种特性很重要，可以让读者在阅读一段新的代码时清楚地知道他们应该把注意力放在哪里。\n标准库中包含了许多这一原则发挥作用的例子。例如：\n在 package sort 中的维护者注释 好的同一软件包中可运行的例子，这对用户（他们会查看 godoc）和维护者（他们作为测试的一部分运行）都有利 strings.Cut 只有四行代码，但它们提高了callsites 的清晰性和正确性 简单 # 你的 Go 代码对于使用、阅读和维护它的人来说应该是简单的。\nGo 代码应该以最简单的方式编写，在行为和性能方面都能实现其目标。在 Google Go 代码库中，简单的代码：\n从头至尾都易于阅读 不预设你已经知道它在做什么 不预设你能记住前面所有的代码 不含非必要的抽象层次 不含过于通用的命名 让读者清楚地了解到传值与决定的传播情况 有注释，解释为什么，而不是代码正在做什么，以避免未来的歧义 有独立的文档 包含有效的错误与失败用例测试 往往不是看起来“聪明”的代码 在代码的简单性和 API 使用的简单性之间可能会需要权衡。例如，让代码更复杂可能是值得的，这样 API 的终端用户可以更容易地正确调用 API。相反，把一些额外的工作留给 API 的终端用户也是值得的，这样代码就会保持简单和容易理解。\n当代码需要复杂性时，应该有意地增加复杂性。如果需要额外的性能，或者一个特定的库或服务有多个不同的客户，这通常是必要的。复杂性可能是合理的，但它应该有相应的文档，以便客户和未来的维护者能够理解和驾驭这种复杂性。这应该用测试和例子来补充，以证明其正确的用法，特别是如果同时有一个“简单”和“复杂”的方法来使用代码。\n这一原则并不意味着复杂的代码不能或不应该用 Go 编写，也不意味着 Go 代码不允许复杂。我们努力使代码库避免不必要的复杂性，因此当复杂性出现时，它表明有关的代码需要仔细理解和维护。理想情况下，应该有相应的注释来解释其中的道理，并指出应该注意的地方。在优化代码以提高性能时，经常会出现这种情况；这样做往往需要更复杂的方法，比如预先分配一个缓冲区并在整个 goroutine 生命周期内重复使用它。当维护者看到这种情况时，应该是一个线索，说明相关的代码是基于性能的关键考虑，这应该影响到未来修改时的谨慎。另一方面，如果不必要地使用，这种复杂性会给那些需要在未来阅读或修改代码的人带来负担。\n如果代码非常复杂，但其目的应该是简单的，这往往是一个我们可以重新审视代码实现的信号，看看是否有更简单的方法来完成同样的事情。\n最小化机制 # 如果有几种方法来表达同一个想法，最好选择使用最标准工具的方法。复杂的机制经常存在，但不应该无缘无故地使用。根据需要增加代码的复杂性是很容易的，而在发现没有必要的情况下删除现有的复杂性则要难得多。\n当足以满足你的使用情况时，争取使用一个核心语言结构（例如通道、切片、地图、循环或结构） 如果没有，就在标准库中寻找一个工具（如 HTTP 客户端或模板引擎） 最后，在引入新的依赖或创建自己的依赖之前，考虑谷歌代码库中是否有一个能够满足的核心库 例如，考虑生产代码包含一个绑定在变量上的标志，它的默认值必须在测试中被覆盖。除非打算测试程序的命令行界面本身（例如，用os/exec），否则直接覆盖绑定的值比使用 flag.Set 更简单，因此更可取。\n同样，如果一段代码需要检查集合的成员资格，一个布尔值的映射（例如，map[string]bool）通常就足够了。只有在需要更复杂的操作，不能使用 map 或过于复杂时，才应使用提供类似集合类型和功能的库。\n简洁 # 简洁的 Go 代码具有很高的信噪比。它很容易分辨出相关的细节，而命名和结构则引导读者了解这些细节。\n而有很多东西会常常会阻碍这些最突出的细节：\n重复代码 外来的语法 含义不明的名称 不必要的抽象 空白 重复代码尤其容易掩盖每个相似代码之间的差异，需要读者直观地比较相似的代码行来发现变化。表驱动测试是一个很好的例子，这种机制可以简明地从每个重复的重要细节中找出共同的代码，但是选择哪些部分包括在表中，会对表格的易懂程度产生影响。\n在考虑多种结构代码的方式时，值得考虑哪种方式能使重要的细节最显著。\n理解和使用常见的代码结构和规范对于保持高信噪比也很重要。例如，下面的代码块在错误处理中非常常见，读者可以很快理解这个代码块的目的。\n// Good: if err := doSomething(); err != nil { // ... } 如果代码看起来非常相似但却有细微的不同，读者可能不会注意到这种变化。在这样的情况下，值得故意“提高”错误检查的信号，增加一个注释以引起关注。\n// Good: if err := doSomething(); err == nil { // if NO error // ... } 可维护性 # 代码被编辑的次数比它写它的次数多得多。可读的代码不仅对试图了解其工作原理的读者有意义，而且对需要改写它的程序员也有意义，清晰性很关键。\n可维护的代码：\n容易让未来的程序员正确进行修改 拥有结构化的 API，使其能够优雅地增加 清楚代码预设条件，并选择映射到问题结构而不是代码结构的抽象 避免不必要的耦合，不包括不使用的功能 有一个全面的测试套件，以确保预期行为可控、重要逻辑正确，并且测试在失败的情况下提供清晰、可操作的诊断 当使用像接口和类型这样的抽象时，根据定义，它们会从使用的上下文中移除信息，因此必须确保它们提供足够的好处。当使用具体类型时，编辑器和 IDE 可以直接连接到方法定义并显示相应的文档，但在其他情况下只能参考接口定义。接口是一个强大的工具，但也是有代价的，因为维护者可能需要了解底层实现的具体细节才能正确使用接口，这必须在接口文档中或在调用现场进行解释。\n可维护的代码还可以避免在容易忽视的地方隐藏重要的细节。例如，在下面的每一行代码中，是否有 : 字符对于理解这一行至关重要。\n// Bad: // 使用 = 而不是 := 可以完全改变这一行的含义 if user, err = db.UserByID(userID); err != nil { // ... } // Bad: // 这行中间的 ！ 很容易错过 leap := (year%4 == 0) \u0026amp;\u0026amp; (!(year%100 == 0) || (year%400 == 0)) 这两种写法不能说错误，但都可以写得更明确，或者可以有一个附带的评论，提醒注意重要的行为。\n// Good: u, err := db.UserByID(userID) if err != nil { return fmt.Errorf(\u0026#34;invalid origin user: %s\u0026#34;, err) } user = u // Good: // 公历闰年不仅仅是 year%4 == 0 // 查看 https://en.wikipedia.org/wiki/Leap_year#Algorithm. var ( leap4 = year%4 == 0 leap100 = year%100 == 0 leap400 = year%400 == 0 ) leap := leap4 \u0026amp;\u0026amp; (!leap100 || leap400) 同样地，一个隐藏了关键逻辑或重要边界情况的辅助函数可能会使未来的变化很容易无法正确地被解释。\n易联想的名字是可维护代码的另一个特点。一个包的用户或一段代码的维护者应该能够联想到一个变量、方法或函数在特定情况下的名称。相同概念的函数参数和接收器名称通常应该共享相同的名称，这既是为了保持文档的可理解性，也是为了方便以最小的开销重构代码。\n可维护的代码尽量减少其依赖性（包括隐性和显性）。对更少包的依赖意味着更少的代码行可以影响其行为。避免对内部或未记录的行为的依赖，使得代码在未来这些行为发生变化时，不太容易造成维护负担。\n在考虑如何构造或编写代码时，值得花时间去思考代码可能随着时间的推移而演变的方式。如果一个给定的方法更有利于未来更容易和更安全的变化，这往往是一个很好的权衡，即使它意味着一个稍微复杂的设计。\n一致 # 一致性的代码是指在更广泛的代码库中，在一个团队或包的范围内，甚至在一个文件中，看起来、感觉和行为都是类似的代码。\n一致性的问题并不凌驾于上述的任何原则之上，但如果必须有所取舍，那往往有利于一致性的实现。\n一个包内的一致性通常是最直接重要的一致性水平。如果同一个问题在一个包里有多种处理方式，或者同一个概念在一个文件里有很多名字，那就会非常不优雅。然而，即使这样，也不应该凌驾于文件的风格原则或全局一致性之上。\n核心准则 # 这些准则收集了所有 Go 代码都应遵循的 Go 风格的最重要方面。我们希望这些原则在你被保障可读性的时候就已经学会并遵循了。这些不会经常改变，新增加内容也有较高准入门槛。\n下面的准则是对 Effective Go 中建议的扩展，它为整个社区的 Go 代码提供了一个共同的基准线。\n格式化 # 所有 Go 源文件必须符合 gofmt 工具所输出的格式。这个格式是由 Google 代码库中的预提交检查强制执行的。生成的代码通常也应该被格式化（例如，通过使用format.Source），因为它也可以在代码搜索中浏览。\n大小写混合 # Go 源代码在编写包含多个字的名称时使用MixedCaps或mixedCaps（驼峰大写）而不是下划线（蛇形大写）。\n即使在其他语言中打破惯例，这也适用。例如，一个常量如果被导出，则为MaxLength（而不是MAX_LENGTH），如果未被导出，则为maxLength（而不是max_length）。\n基于初始化大小写的考量，本地变量被认为是 不可导出的。\n行长度 # Go 源代码没有固定的行长度。如果觉得某一行太长，就应该对其进行重构而不是破坏。如果它已经很短了，那么就应该允许它继续增加。\n不要在以下情况进行分行：\n在缩进变化之前(例如，函数声明、条件) 要使一个长的字符串（例如，一个 URL）适合于多个较短的行 命名 # 命名是艺术而不是科学。在 Go 中，名字往往比许多其他语言的名字短一些，但同样的一般准则也适用，名称应：\n使用时不感到重复 将上下文考虑在内 不重复已经明确的概念 你可以在决定中找到关于命名的更具体的指导。\n本地化一致性 # 如果风格指南对某一特定的风格点没有说明，作者可以自由选择他们喜欢的风格，除非相近的代码（通常在同一个文件或包内，但有时在一个团队或项目目录内）对这个问题采取了一致的立场。\n有效的本地风格化考虑例子：\n使用 %s or %v 来打印错误 使用缓冲通道来代替 mutexes 无效的本地化风格化考虑例子：\n代码的行长限制 使用基于断言的测试库 如果本地化风格与风格指南不一致，但对可读性的影响仅限于一个文件，它通常会在代码审查中浮出水面，而一致的修复将超出有关 CL 的范围。在这一点上，提交一个 bug 来跟踪修复是合适的。\n如果一个改变会使现有的风格偏差变大，在更多的 API 表面暴露出来，扩大存在偏差的文件数量，或者引入一个实际的错误，那么局部一致性就不再是违反新代码风格指南的有效理由。在这些情况下，作者应该在同一 CL 中清理现有的代码库，在当前 CL 之前进行重构，或者找到一个至少不会使本地化问题恶化的替代方案。\n"},{"id":2,"href":"/styleguide/docs/03-decisions/","title":"03 Decisions","section":"Docs","content":" Go 风格决策 # https://google.github.io/styleguide/go/decisions\n概述 | 指南 | 决策 | 最佳实践\n**注意：**本文是 Google Go 风格 系列文档的一部分。本文档是 规范性(normative) 但不是强制规范(canonical)，并且从属于Google 风格指南。请参阅概述获取更多详细信息。\n关于 # 本文包含旨在统一和为 Go 可读性导师给出的建议提供标准指导、解释和示例的风格决策。\n本文档并不详尽，且会随着时间的推移而增加。如果风格指南 与此处给出的建议相矛盾，风格指南优先，并且本文档应相应更新。\n参见 关于 获取 Go 风格的全套文档。\n以下部分已从样式决策移至指南的一部分：\n混合大写字母MixedCaps: 参见 https://google.github.io/styleguide/go/guide#mixed-caps 格式化Formatting: 参见 https://google.github.io/styleguide/go/guide#formatting 行长度Line Length: 参见 https://google.github.io/styleguide/go/guide#line-length 命名Naming # 有关命名的总体指导，请参阅核心风格指南 中的命名部分，以下部分对命名中的特定区域提供进一步的说明。\n下划线Underscores # Go 中的命名通常不应包含下划线。 这个原则有三个例外：\n仅由生成代码导入的包名称可能包含下划线。有关如何选择多词包名称的更多详细信息，请参阅包名称。 *_test.go 文件中的测试、基准和示例函数名称可能包含下划线。 与操作系统或 cgo 互操作的低级库可能会重用标识符，如 syscall 中所做的那样。在大多数代码库中，这预计是非常罕见的。 包名称Package names # Go 包名称应该简短并且只包含小写字母。由多个单词组成的包名称应全部小写。例如，包 tabwriter 不应该命名为 tabWriter、TabWriter 或 tab_writer。\n避免选择可能被常用局部变量遮蔽覆盖 的包名称。例如，usercount 是比 count 更好的包名，因为 count 是常用变量名。\nGo 包名称不应该有下划线。如果您需要导入名称中确实有一个包（通常来自生成的或第三方代码），则必须在导入时将其重命名为适合在 Go 代码中使用的名称。\n一个例外是仅由生成的代码导入的包名称可能包含下划线。具体例子包括：\n对外部测试包使用 _test 后缀，例如集成测试 使用 _test 后缀作为 包级文档示例 避免使用无意义的包名称，例如 util、utility、common、helper 等。查看更多关于所谓的“实用程序包”。\n当导入的包被重命名时（例如 import foob \u0026quot;path/to/foo_go_proto\u0026quot;），包的本地名称必须符合上述规则，因为本地名称决定了包中的符号在文件中的引用方式.如果给定的导入在多个文件中重命名，特别是在相同或附近的包中，则应尽可能使用相同的本地名称以保持一致性。\n另请参阅：https://go.dev/blog/package-names\n接收者命名Receiver names # 接收者 变量名必须满足:\n短（通常是一两个字母的长度） 类型本身的缩写 始终如一地应用于该类型的每个接收者 长名称 更好命名 func (tray Tray) func (t Tray) func (info *ResearchInfo) func (ri *ResearchInfo) func (this *ReportWriter) func (w *ReportWriter) func (self *Scanner) func (s *Scanner) 常量命名Constant names # 常量名称必须像 Go 中的所有其他名称一样使用 混合大写字母MixedCaps。 （导出 常量以大写字母开头，而未导出的常量以小写字母开头。）即使打破了其他语言的约定，这也是适用的。常量名称不应是其值的派生词，而应该解释值锁表示的含义。\n// Good: const MaxPacketSize = 512 const ( ExecuteBit = 1 \u0026lt;\u0026lt; iota WriteBit ReadBit ) 不要使用非混合大写常量名称或带有 K 前缀的常量。\n// Bad: const MAX_PACKET_SIZE = 512 const kMaxBufferSize = 1024 const KMaxUsersPergroup = 500 根据它们的角色而不是它们的值来命名常量。 如果一个常量除了它的值之外没有其他作用，那么就没有必要将它定义为一个常量。\n// Bad: const Twelve = 12 const ( UserNameColumn = \u0026#34;username\u0026#34; GroupColumn = \u0026#34;group\u0026#34; ) 缩写词Initialisms # 名称中的首字母缩略词或单独的首字母缩略词（例如，“URL”和“NATO”）应该具有相同的大小写。 URL 应显示为 URL 或 url（如 urlPony 或 URLPony），绝不能显示为 Url。 这也适用于 ID 是“identifier”的缩写； 写 appID 而不是 appId。\n在具有多个首字母缩写的名称中（例如 XMLAPI 因为它包含 XML 和 API），给定首字母缩写中的每个字母都应该具有相同的大小写，但名称中的每个首字母缩写不需要具有相同的大小写。 在带有包含小写字母的首字母缩写的名称中（例如DDoS、iOS、gRPC），首字母缩写应该像在标准中一样出现，除非您需要为了满足 导出 而更改第一个字母。在这些情况下，整个缩写词应该是相同的情况（例如 ddos、IOS、GRPC）。 缩写词 范围 正确 错误 XML API Exported XMLAPI XmlApi, XMLApi, XmlAPI, XMLapi XML API Unexported xmlAPI xmlapi, xmlApi iOS Exported IOS Ios, IoS iOS Unexported iOS ios gRPC Exported GRPC Grpc gRPC Unexported gRPC grpc DDoS Exported DDoS DDOS, Ddos DDoS Unexported ddos dDoS, dDOS Get方法Getters # 函数和方法名称不应使用 Get 或 get 前缀，除非底层概念使用单词“get”（例如 HTTP GET）。此时，更应该直接以名词开头的名称，例如使用 Counts 而不是 GetCounts。\n如果该函数涉及执行复杂的计算或执行远程调用，则可以使用Compute 或 Fetch等不同的词代替Get，以使读者清楚函数调用可能需要时间和 可能会阻塞或失败。\n变量名Variable names # 一般的经验法则是，名称的长度应与其范围的大小成正比，并与其在该范围内使用的次数成反比。在文件范围内创建的变量可能需要多个单词，而单个内部块作用域内的变量可能是单个单词甚至只是一两个字符，以保持代码清晰并避免无关信息。\n这是一条粗略的基线。这些数字准则不是严格的规则。要根据上下文、清晰 和[简洁](https://google.github.io/styleguide/go/guide#简洁）来进行判断。\n小范围是执行一两个小操作的范围，比如 1-7 行。 中等范围是一些小的或一个大的操作，比如 8-15 行。 大范围是一个或几个大操作，比如 15-25 行。 非常大的范围是指超过一页（例如，超过 25 行）的任何内容。 在小范围内可能非常清楚的名称（例如，c 表示计数器）在较大范围内可能不够用，并且需要澄清以提醒进一步了解其在代码中的用途。一个作用域中有很多变量，或者表示相似值或概念的变量，那就可能需要比作用域建议的采用更长的变量名称。\n概念的特殊性也有助于保持变量名称的简洁。例如，假设只有一个数据库在使用，像db这样的短变量名通常可能保留给非常小的范围，即使范围非常大，也可能保持完全清晰。在这种情况下，根据范围的大小，单个词database可能是可接受的，但不是必需的，因为db是该词的一种非常常见的缩写，几乎没有其他解释。\n局部变量的名称应该反映它包含的内容以及它在当前上下文中的使用方式，而不是值的来源。例如，通常情况下最佳局部变量名称与结构或协议缓冲区字段名称不同。\n一般来说：\n像 count 或 options 这样的单字名称是一个很好的起点。\n可以添加其他词来消除相似名称的歧义，例如 userCount 和 projectCount。\n不要简单地省略字母来节省打字时间。例如，Sandbox 优于 Sbx，特别是对于导出的名称。\n大多数变量名可省略 类型和类似类型的词\n对于数字，userCount 是比 numUsers 或 usersInt 更好的名称。 对于切片，users 是一个比 userSlice 更好的名字。 如果范围内有两个版本的值，则包含类似类型的限定符是可以接受的，例如，您可能将输入存储在 ageString 中，并使用 age 作为解析值。 省略上下文 中清楚的单词。例如，在 UserCount 方法的实现中，名为 userCount 的局部变量可能是多余的； count、users 甚至 c 都具有可读性。\n单字母变量名Single-letter variable names # 单字母变量名是可以减少重复 的有用工具，但也可能使代码变得不透明。将它们的使用限制在完整单词很明显以及它会重复出现以代替单字母变量的情况。\n一般来说：\n对于方法接收者变量，最好使用一个字母或两个字母的名称。 对常见类型使用熟悉的变量名通常很有帮助： r 用于 io.Reader 或 *http.Request w 用于 io.Writer 或 http.ResponseWriter 单字母标识符作为整数循环变量是可接受的，特别是对于索引（例如，i）和坐标（例如，x 和 y）。 当范围很短时，循环标识符使用缩写是可接受的，例如for _, n := range nodes { ... }。 重复Repetition # 一段 Go 源代码应该避免不必要的重复。 一个常见的情形是重复名称，其中通常包含不必要的单词或重复其上下文或类型。 如果相同或相似的代码段在很近的地方多次出现，代码本身也可能是不必要的重复。\n重复命名可以有多种形式，包括：\n包名 vs 可导出符号名Package vs. exported symbol name # 当命名导出的符号时，包的名称始终在包外可见，因此应减少或消除两者之间的冗余信息。如果一个包如果需要仅导出一种类型并且以包本身命名，则构造函数的规范名称是New（如果需要的话）。\n实例: 重复的名称 -\u0026gt; 更好的名称\nwidget.NewWidget -\u0026gt; widget.New widget.NewWidgetWithName -\u0026gt; widget.NewWithName db.LoadFromDatabase -\u0026gt; db.Load goatteleportutil.CountGoatsTeleported -\u0026gt; gtutil.CountGoatsTeleported or goatteleport.Count myteampb.MyTeamMethodRequest -\u0026gt; mtpb.MyTeamMethodRequest or myteampb.MethodRequest 变量名 vs 类型Variable name vs. type # 编译器总是知道变量的类型，并且在大多数情况下，阅读者也可以通过变量的使用方式清楚地知道变量是什么类型。只有当一个变量的值在同一范围内出现两次时，才有需要明确变量的类型。\n重复的名称 更好的名称 var numUsers int var users int var nameString string var name string var primaryProject *Project var primary *Project 如果该值以多种形式出现，这可以通过额外的词（如raw和parsed）或底层表示来澄清：\n// Good: limitStr := r.FormValue(\u0026#34;limit\u0026#34;) limit, err := strconv.Atoi(limitStr) // Good: limitRaw := r.FormValue(\u0026#34;limit\u0026#34;) limit, err := strconv.Atoi(limitRaw) 外部上下文 vs 本地名称External context vs. local names # 包含来自周围上下文信息的名称通常会产生额外的噪音，而没有任何好处。 包名、方法名、类型名、函数名、导入路径，甚至文件名都可以提供自动限定其名称的上下文。 Names that include information from their surrounding context often create extra noise without benefit. The package name, method name, type name, function name, import path, and even filename can all provide context that automatically qualifies all names within.\n// Bad: // In package \u0026#34;ads/targeting/revenue/reporting\u0026#34; type AdsTargetingRevenueReport struct{} func (p *Project) ProjectName() string // Good: // In package \u0026#34;ads/targeting/revenue/reporting\u0026#34; type Report struct{} func (p *Project) Name() string // Bad: // In package \u0026#34;sqldb\u0026#34; type DBConnection struct{} // Good: // In package \u0026#34;sqldb\u0026#34; type Connection struct{} // Bad: // In package \u0026#34;ads/targeting\u0026#34; func Process(in *pb.FooProto) *Report { adsTargetingID := in.GetAdsTargetingID() } // Good: // In package \u0026#34;ads/targeting\u0026#34; func Process(in *pb.FooProto) *Report { id := in.GetAdsTargetingID() } 重复通常应该在符号用户的上下文中进行评估，而不是孤立地进行评估。例如，下面的代码有很多名称，在某些情况下可能没问题，但在上下文中是多余的：\n// Bad: func (db *DB) UserCount() (userCount int, err error) { var userCountInt64 int64 if dbLoadError := db.LoadFromDatabase(\u0026#34;count(distinct users)\u0026#34;, \u0026amp;userCountInt64); dbLoadError != nil { return 0, fmt.Errorf(\u0026#34;failed to load user count: %s\u0026#34;, dbLoadError) } userCount = int(userCountInt64) return userCount, nil } 相反，在上下文和使用上信息是清楚的情况下，常常可以忽略：\n// Good: func (db *DB) UserCount() (int, error) { var count int64 if err := db.Load(\u0026#34;count(distinct users)\u0026#34;, \u0026amp;count); err != nil { return 0, fmt.Errorf(\u0026#34;failed to load user count: %s\u0026#34;, err) } return int(count), nil } 评论Commentary # 关于评论的约定（包括评论什么、使用什么风格、如何提供可运行的示例等）旨在支持阅读公共 API 文档的体验。 有关详细信息，请参阅 Effective Go。\n最佳实践文档关于 文档约定 的部分进一步讨论了这一点。\n**最佳实践：**在开发和代码审查期间使用文档预览 查看文档和可运行示例是否有用 并以您期望的方式呈现。\n提示： Godoc 使用很少的特殊格式； 列表和代码片段通常应该缩进以避免换行。 除缩进外，通常应避免装饰。\n注释行长度Comment line length # 确保即使在较窄的屏幕上注释的可读性。\n当评论变得太长时，建议将其包装成多个单行评论。在可能的情况下，争取在 80 列宽的终端上阅读良好的注释，但这并不是硬性限制； Go 中的注释没有固定的行长度限制。例如，标准库经常选择根据标点符号来打断注释，这有时会使个别行更接近 60-70 个字符标记。\n有很多现有代码的注释长度超过 80 个字符。本指南不应作为更改此类代码作为可读性审查的一部分的理由（请参阅一致性），但鼓励团队作为其他重构的一部分，有机会时更新注释以遵循此指南。本指南的主要目标是确保所有 Go 可读性导师在提出建议时以及是否提出相同的建议。\n有关评论的更多信息，请参阅此 来自 The Go Blog 的帖子。\n# Good: // This is a comment paragraph. // The length of individual lines doesn\u0026#39;t matter in Godoc; // but the choice of wrapping makes it easy to read on narrow screens. // // Don\u0026#39;t worry too much about the long URL: // https://supercalifragilisticexpialidocious.example.com:8080/Animalia/Chordata/Mammalia/Rodentia/Geomyoidea/Geomyidae/ // // Similarly, if you have other information that is made awkward // by too many line breaks, use your judgment and include a long line // if it helps rather than hinders. 避免在小屏幕上重复换行的评论，这是一种糟糕的阅读体验。\n# Bad: // This is a comment paragraph. The length of individual lines doesn\u0026#39;t matter in Godoc; // but the choice of wrapping causes jagged lines on narrow screens or in Critique, // which can be annoying, especially when in a comment block that will wrap repeatedly. // // Don\u0026#39;t worry too much about the long URL: // https://supercalifragilisticexpialidocious.example.com:8080/Animalia/Chordata/Mammalia/Rodentia/Geomyoidea/Geomyidae/ 文档注释Doc comments # 所有顶级导出名称都必须有文档注释，具有不明显行为或含义的未导出类型或函数声明也应如此。 这些注释应该是完整句子，以所描述对象的名称开头。 冠词（“a”、“an”、“the”）可以放在名字前面，使其读起来更自然。\n// Good: // A Request represents a request to run a command. type Request struct { ... // Encode writes the JSON encoding of req to w. func Encode(w io.Writer, req *Request) { ... 文档注释出现在 Godoc 中，并通过 IDE 显示，因此应该为使用该包的任何人编写文档注释。\n如果出现在结构中，文档注释适用于以下符号或字段组：\n// Good: // Options configure the group management service. type Options struct { // General setup: Name string Group *FooGroup // Dependencies: DB *sql.DB // Customization: LargeGroupThreshold int // optional; default: 10 MinimumMembers int // optional; default: 2 } **最佳实践：**如果你对未导出的代码有文档注释，请遵循与导出代码相同的习惯（即，以未导出的名称开始注释）。 这使得以后导出它变得容易，只需在注释和代码中用新导出的名称替换未导出的名称即可。\n注释语句Comment sentences # 完整句子的注释应该像标准英语句子一样大写和标点符号。 （作为一个例外，如果在其他方面很清楚，可以以非大写的标识符名称开始一个句子。这种情况最好只在段落的开头进行。）\n作为句子片段的注释对标点符号或大小写没有此类要求。\n文档注释 应始终是完整的句子，因此应始终大写和标点符号。 简单的行尾注释（特别是对于结构字段）可以假设字段名称是主语的简单短语。\n// Good: // A Server handles serving quotes from the collected works of Shakespeare. type Server struct { // BaseDir points to the base directory under which Shakespeare\u0026#39;s works are stored. // // The directory structure is expected to be the following: // {BaseDir}/manifest.json // {BaseDir}/{name}/{name}-part{number}.txt BaseDir string WelcomeMessage string // displayed when user logs in ProtocolVersion string // checked against incoming requests PageLength int // lines per page when printing (optional; default: 20) } 示例Examples # 包应该清楚地记录它们的预期用途。 尝试提供一个可运行的例子； 示例出现在 Godoc 中。 可运行示例属于测试文件，而不是生产源文件。 请参阅此示例（Godoc，[source](https://cs.opensource.google/go/go/+/HEAD:src/time /example_test.go））。\n如果无法提供可运行的示例，可以在代码注释中提供示例代码。 与注释中的其他代码和命令行片段一样，它应该遵循标准格式约定。\n命名的结果参数Named result parameters # 当有命名参数时，请考虑函数签名在 Godoc 中的显示方式。 函数本身的名称和结果参数的类型通常要足够清楚。\n// Good: func (n *Node) Parent1() *Node func (n *Node) Parent2() (*Node, error) 如果一个函数返回两个或多个相同类型的参数，添加名称会很有用。\n// Good: func (n *Node) Children() (left, right *Node, err error) 如果调用者必须对特定的结果参数采取行动，命名它们可以帮助暗示行动是什么：\n// Good: // WithTimeout returns a context that will be canceled no later than d duration // from now. // // The caller must arrange for the returned cancel function to be called when // the context is no longer needed to prevent a resource leak. func WithTimeout(parent Context, d time.Duration) (ctx Context, cancel func()) 在上面的代码中，取消是调用者必须执行的特定操作。但是，如果将结果参数单独写为(Context, func())，“取消函数”的含义就不清楚了。\n当名称产生 不必要的重复 时，不要使用命名结果参数。\n// Bad: func (n *Node) Parent1() (node *Node) func (n *Node) Parent2() (node *Node, err error) 不要为了避免在函数内声明变量而使用命名结果参数。这种做法会导致不必要的 冗长API，但收益只是很小的简洁性。\n裸返回 仅在小函数中是可接受的。 一旦它是一个中等大小的函数，就需要明确你的返回值。 同样，不要仅仅因为可以裸返回就使用命名结果参数。 清晰度 总是比在你的函数中节省几行更重要。\n如果必须在延迟闭包中更改结果参数的值，则命名结果参数始终是可以接受的。\n提示： 类型通常比函数签名中的名称更清晰。 GoTip #38：作为命名类型的函数 演示了这一点。\n在上面的 WithTimeout 中，代码使用了一个 CancelFunc 而不是结果参数列表中的原始func()，并且几乎不需要做任何记录工作。\n包注释 # 包注释必须出现在包内语句的上方，注释和包名称之间没有空行。 例子：\n// Good: // Package math provides basic constants and mathematical functions. // // This package does not guarantee bit-identical results across architectures. package math 每个包必须有一个包注释。 如果一个包由多个文件组成，那么其中一个文件应该有包注释。\nmain 包的注释形式略有不同，其中 BUILD 文件中的 go_binary 规则的名称代替了包名。\n// Good: // The seed_generator command is a utility that generates a Finch seed file // from a set of JSON study configs. package main 只要二进制文件的名称与 BUILD 文件中所写的完全一致，其他风格的注释也是可以了。 当二进制名称是第一个单词时，即使它与命令行调用的拼写不严格匹配，也需要将其大写。\n// Good: // Binary seed_generator ... // Command seed_generator ... // Program seed_generator ... // The seed_generator command ... // The seed_generator program ... // Seed_generator ... 提示:\n命令行调用示例和 API 用法可以是有用的文档。 对于 Godoc 格式，缩进包含代码的注释行。\n如果没有明显的主文件或者包注释特别长，可以将文档注释放在名为 doc.go 的文件中，只有注释和包子句。\n可以使用多行注释代替多个单行注释。 如果文档包含可能对从源文件复制和粘贴有用的部分，如示例命令行（用于二进制文件）和模板示例，这将非常有用。\n// Good: /* The seed_generator command is a utility that generates a Finch seed file from a set of JSON study configs. seed_generator *.json | base64 \u0026gt; finch-seed.base64 */ package template 供维护者使用且适用于整个文件的注释通常放在导入声明之后。 这些不会出现在 Godoc 中，也不受上述包注释规则的约束。\n导入 # 导入重命名 # 只有在为了避免与其他导入的名称冲突时，才使用重命名导入。 （由此推论，好的包名称 不需要重命名。）如果发生名称冲突，最好重命名 最本地或特定于项目的导入。 包的本地别名必须遵循包命名指南，包括禁止使用下划线和大写字母。\n生成的 protocol buffer 包必须重命名以从其名称中删除下划线，并且它们的别名必须具有 pb 后缀。 有关详细信息，请参阅proto和stub最佳实践。\n// Good: import ( fspb \u0026#34;path/to/package/foo_service_go_proto\u0026#34; ) 导入的包名称没有有用的识别信息时（例如 package v1），应该重命名以包括以前的路径组件。 重命名必须与导入相同包的其他本地文件一致，并且可以包括版本号。\n注意： 最好重命名包以符合 好的包命名规则，但在vendor目录下的包通常是不可行的。\n// Good: import ( core \u0026#34;github.com/kubernetes/api/core/v1\u0026#34; meta \u0026#34;github.com/kubernetes/apimachinery/pkg/apis/meta/v1beta1\u0026#34; ) 如果您需要导入一个名称与您要使用的公共局部变量名称（例如 url、ssh）冲突的包，并且您希望重命名该包，首选方法是使用 pkg 后缀（例如 urlpkg）。 请注意，可以使用局部变量隐藏包； 仅当此类变量在范围内时仍需要使用此包时，才需要重命名。\n导入分组 # 导入应分为两组：\n标准库包 其他（项目和vendor）包 // Good: package main import ( \u0026#34;fmt\u0026#34; \u0026#34;hash/adler32\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/dsnet/compress/flate\u0026#34; \u0026#34;golang.org/x/text/encoding\u0026#34; \u0026#34;google.golang.org/protobuf/proto\u0026#34; foopb \u0026#34;myproj/foo/proto/proto\u0026#34; _ \u0026#34;myproj/rpc/protocols/dial\u0026#34; _ \u0026#34;myproj/security/auth/authhooks\u0026#34; ) 将导入项分成多个组是可以接受的，例如，如果您想要一个单独的组来重命名、导入仅为了特殊效果 或另一个特殊的导入组。\n// Good: package main import ( \u0026#34;fmt\u0026#34; \u0026#34;hash/adler32\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/dsnet/compress/flate\u0026#34; \u0026#34;golang.org/x/text/encoding\u0026#34; \u0026#34;google.golang.org/protobuf/proto\u0026#34; foopb \u0026#34;myproj/foo/proto/proto\u0026#34; _ \u0026#34;myproj/rpc/protocols/dial\u0026#34; _ \u0026#34;myproj/security/auth/authhooks\u0026#34; ) 注意： goimports 不支持维护可选组 - 超出标准库和 Google 导入之间强制分离所需的拆分。为了保持符合状态，额外的导入子组需要作者和审阅人的注意。\nGoogle 程序有时也是 AppEngine 应用程序，应该有一个单独的组用于 AppEngine 导入。\nGofmt 负责按导入路径对每个组进行排序。但是，它不会自动将导入分成组。流行的 goimports 工具结合了 Gofmt 和导入管理，根据上述规则将导入进行分组。通过 goimports 来管理导入安排是可行的，但随着文件的修改，其导入列表必须保持内部一致。\n导入\u0026quot;空\u0026quot; (import _) # 使用语法 import _ \u0026quot;package\u0026quot;导入的包，称为副作用导入，只能在主包或需要它们的测试中导入。\n此类软件包的一些示例包括：\ntime/tzdata image/jpeg 在图像处理中的代码 避免在工具包中导入空白，即使工具包间接依赖于它们。 将副作用导入限制到主包有助于控制依赖性，并使得编写依赖于不同导入的测试成为可能，而不会发生冲突或浪费构建成本。\n以下是此规则的唯一例外情况：\n您可以使用空白导入来绕过 nogo 静态检查器 中对不允许导入的检查。 您可以在使用 //go:embed 编译器指令的源文件中使用 embed 包的空白导入。 **提示：**如果生产环境中您创建的工具包间接依赖于副作用导入，请记录这里的预期用途。\n导入 “.” (import .) # import . 形式是一种语言特性，它允许将从另一个包导出的标识符无条件地带到当前包中。 有关更多信息，请参阅语言规范。\n不要在 Google 代码库中使用此功能； 这使得更难判断功能来自何处。\n// Bad: package foo_test import ( \u0026#34;bar/testutil\u0026#34; // also imports \u0026#34;foo\u0026#34; . \u0026#34;foo\u0026#34; ) var myThing = Bar() // Bar defined in package foo; no qualification needed. // Good: package foo_test import ( \u0026#34;bar/testutil\u0026#34; // also imports \u0026#34;foo\u0026#34; \u0026#34;foo\u0026#34; ) var myThing = foo.Bar() 错误 # 返回错误 # 使用 error 表示函数可能会失败。 按照惯例，error 是最后一个结果参数。\n// Good: func Good() error { /* ... */ } 返回 nil 错误是表示操作成功的惯用方式，否则表示可能会失败。 如果函数返回错误，除非另有明确说明，否则调用者必须将所有非错误返回值视为未确定。 通常来说，非错误返回值是它们的零值，但也不能直接这么假设。\n// Good: func GoodLookup() (*Result, error) { // ... if err != nil { return nil, err } return res, nil } 返回错误的导出函数应使用error类型返回它们。 具体的错误类型容易受到细微错误的影响：一个 nil 指针可以包装到接口中，从而就变成非 nil 值（参见 关于该主题的 Go FAQ 条目）。\n// Bad: func Bad() *os.PathError { /*...*/ } 提示：采用 context.Context 参数的函数通常应返回 error，以便调用者可以确定上下文是否在函数运行时被取消。\n错误字符串 # 错误字符串不应大写（除非以导出名称、专有名词或首字母缩写词开头）并且不应以标点符号结尾。 这是因为错误字符串通常在打印给用户之前出现在其他上下文中。\n// Bad: err := fmt.Errorf(\u0026#34;Something bad happened.\u0026#34;) // Good: err := fmt.Errorf(\u0026#34;something bad happened\u0026#34;) 另一方面，完整显示消息（日志记录、测试失败、API 响应或其他 UI）的样式视情况而定，但通常应大写首字母。\n// Good: log.Infof(\u0026#34;Operation aborted: %v\u0026#34;, err) log.Errorf(\u0026#34;Operation aborted: %v\u0026#34;, err) t.Errorf(\u0026#34;Op(%q) failed unexpectedly; err=%v\u0026#34;, args, err) 错误处理 # 遇到错误的代码应该慎重选择如何处理它。 使用 _ 变量丢弃错误通常是不合适的。 如果函数返回错误，请执行以下操作之一：\n立即处理并解决错误 将错误返回给调用者 在特殊情况下，调用 log.Fatal 或（如绝对有必要）则调用 panic 注意： log.Fatalf 不是标准库日志。 参见 [#logging]。\n在极少数情况下适合忽略或丢弃错误（例如调用 (*bytes.Buffer).Write 被记录为永远不会失败），随附的注释应该解释为什么这是安全的。\n// Good: var b *bytes.Buffer n, _ := b.Write(p) // never returns a non-nil error 关于错误处理的更多讨论和例子，请参见Effective Go和最佳实践。\nIn-band 错误 # 在C和类似语言中，函数通常会返回-1、null或空字符串等值，以示错误或丢失结果。这就是所谓的带内In-band处理。\n// Bad: // Lookup returns the value for key or -1 if there is no mapping for key. func Lookup(key string) int 未能检查In-band错误值会导致错误，并可能将error归于错误的功能。\n// Bad: // The following line returns an error that Parse failed for the input value, // whereas the failure was that there is no mapping for missingKey. return Parse(Lookup(missingKey)) Go对多重返回值的支持提供了一个更好的解决方案（见Effective Go关于多重返回的部分）。与其要求调用方检查In-band的错误值，函数更应该返回一个额外的值来表明返回值是否有效。这个返回值可以是一个错误，或者在不需要解释时是一个布尔值，并且应该是最终的返回值。\n// Good: // Lookup returns the value for key or ok=false if there is no mapping for key. func Lookup(key string) (value string, ok bool) 这个API可以防止调用者错误地编写Parse(Lookup(key))，从而导致编译时错误，因为Lookup(key)有两个返回值。\n以这种方式返回错误，可以鼓励更强大和明确的错误处理。\n// Good: value, ok := Lookup(key) if !ok { return fmt.Errorf(\u0026#34;no value for %q\u0026#34;, key) } return Parse(value) 一些标准库函数，如包strings中的函数，返回In-band错误值。这大大简化了字符串处理的代码，但代价是要求程序员更加勤奋。一般来说，Google代码库中的Go代码应该为错误返回额外的值。\n缩进错误流程 # 在继续代码的其余部分之前处理错误。这提高了代码的可读性，使读者能够快速找到正常路径。这个逻辑同样适用于任何测试条件并以终端条件结束的代码块（例如，return、panic、log.Fatal）。\n如果终止条件没有得到满足，运行的代码应该出现在if块之后，而不应该缩进到else子句中。\n// Good: if err != nil { // error handling return // or continue, etc. } // normal code // Bad: if err != nil { // error handling } else { // normal code that looks abnormal due to indentation } **提示：**如果你使用一个变量超过几行代码，通常不值得使用带有初始化的if风格。在这种情况下，通常最好将声明移出，使用标准的if语句。\n// Good: x, err := f() if err != nil { // error handling return } // lots of code that uses x // across multiple lines // Bad: if x, err := f(); err != nil { // error handling return } else { // lots of code that uses x // across multiple lines } 更多细节见Go Tip #1：视线和TotT：通过减少嵌套降低代码的复杂性。\n语言 # 字面格式化 # Go有一个非常强大的复合字面语法，用它可以在一个表达式中表达深度嵌套的复杂值。在可能的情况下，应该使用这种字面语法，而不是逐字段建值。字面意义的 gofmt格式一般都很好，但有一些额外的规则可以使这些字面意义保持可读和可维护。\n字段名称 # 对于在当前包之外定义的类型，结构体字面量通常应该指定字段名。\n包括来自其他包的类型的字段名。\n// Good: good := otherpkg.Type{A: 42} 结构中字段的位置和字段的完整集合（当字段名被省略时，这两者都是有必要搞清楚的）通常不被认为是结构的公共API的一部分；需要指定字段名以避免不必要的耦合。\n// Bad: // https://pkg.go.dev/encoding/csv#Reader r := csv.Reader{\u0026#39;,\u0026#39;, \u0026#39;#\u0026#39;, 4, false, false, false, false} 在小型、简单的结构中可以省略字段名，这些结构的组成和顺序都有文档证明是稳定的。\n// Good: okay := image.Point{42, 54} also := image.Point{X: 42, Y: 54} 对于包内类型，字段名是可选的。\n// Good: okay := Type{42} also := internalType{4, 2} 如果能使代码更清晰，还是应该使用字段名，而且这样做是很常见的。例如，一个有大量字段的结构几乎都应该用字段名来初始化。\n// Good: okay := StructWithLotsOfFields{ field1: 1, field2: \u0026#34;two\u0026#34;, field3: 3.14, field4: true, } 匹配的大括号 # 一对大括号的最后一半应该总是出现在一行中，其缩进量与开头的大括号相同。单行字词必然具有这个属性。当字面意义跨越多行时，保持这一属性可以使字面意义的括号匹配与函数和if语句等常见Go语法结构的括号匹配相同。\n这方面最常见的错误是在多行结构字中把收尾括号与值放在同一行。在这种情况下，该行应以逗号结束，收尾括号应出现在下一行。\n// Good: good := []*Type{{Key: \u0026#34;value\u0026#34;}} // Good: good := []*Type{ {Key: \u0026#34;multi\u0026#34;}, {Key: \u0026#34;line\u0026#34;}, } // Bad: bad := []*Type{ {Key: \u0026#34;multi\u0026#34;}, {Key: \u0026#34;line\u0026#34;}} // Bad: bad := []*Type{ { Key: \u0026#34;value\u0026#34;}, } Cuddled 大括号 # 只有在以下两种情况下，才允许在大括号之间为切片和数组丢弃空格（又称 \u0026ldquo;“cuddling”）。\n缩进匹配 内部值也是字面意义或原语构建者（即不是变量或其他表达式） // Good: good := []*Type{ { // Not cuddled Field: \u0026#34;value\u0026#34;, }, { Field: \u0026#34;value\u0026#34;, }, } // Good: good := []*Type{{ // Cuddled correctly Field: \u0026#34;value\u0026#34;, }, { Field: \u0026#34;value\u0026#34;, }} // Good: good := []*Type{ first, // Can\u0026#39;t be cuddled {Field: \u0026#34;second\u0026#34;}, } // Good: okay := []*pb.Type{pb.Type_builder{ Field: \u0026#34;first\u0026#34;, // Proto Builders may be cuddled to save vertical space }.Build(), pb.Type_builder{ Field: \u0026#34;second\u0026#34;, }.Build()} // Bad: bad := []*Type{ first, { Field: \u0026#34;second\u0026#34;, }} 重复的类型名称 # 重复的类型名称可以从slice和map字面上省略，这对减少杂乱是有帮助的。明确重复类型名称的一个合理场合，当在你的项目中处理一个不常见的复杂类型时，当重复的类型名称在相隔很远的行上时，可以提醒读者的上下文。\n// Good: good := []*Type{ {A: 42}, {A: 43}, } // Bad: repetitive := []*Type{ \u0026amp;Type{A: 42}, \u0026amp;Type{A: 43}, } // Good: good := map[Type1]*Type2{ {A: 1}: {B: 2}, {A: 3}: {B: 4}, } // Bad: repetitive := map[Type1]*Type2{ Type1{A: 1}: \u0026amp;Type2{B: 2}, Type1{A: 3}: \u0026amp;Type2{B: 4}, } **提示：**如果你想删除结构字中重复的类型名称，可以运行gofmt -s。\n零值字段 # 零值字段可以从结构字段中省略，但不能因此而失去清晰度。\n设计良好的API经常采用零值结构来提高可读性。例如，从下面的结构中省略三个零值字段，可以使人们注意到正在指定的唯一选项。\n// Bad: import ( \u0026#34;github.com/golang/leveldb\u0026#34; \u0026#34;github.com/golang/leveldb/db\u0026#34; ) ldb := leveldb.Open(\u0026#34;/my/table\u0026#34;, \u0026amp;db.Options{ BlockSize int: 1\u0026lt;\u0026lt;16, ErrorIfDBExists: true, // These fields all have their zero values. BlockRestartInterval: 0, Comparer: nil, Compression: nil, FileSystem: nil, FilterPolicy: nil, MaxOpenFiles: 0, WriteBufferSize: 0, VerifyChecksums: false, }) // Good: import ( \u0026#34;github.com/golang/leveldb\u0026#34; \u0026#34;github.com/golang/leveldb/db\u0026#34; ) ldb := leveldb.Open(\u0026#34;/my/table\u0026#34;, \u0026amp;db.Options{ BlockSize int: 1\u0026lt;\u0026lt;16, ErrorIfDBExists: true, }) 表驱动的测试中的结构经常受益于显式字段名，特别是当测试结构不是琐碎的时候。这允许作者在有关字段与测试用例无关时完全省略零值字段。例如，成功的测试案例应该省略任何与错误或失败相关的字段。在零值对于理解测试用例是必要的情况下，例如测试零或 nil 输入，应该指定字段名。\n简明\ntests := []struct { input string wantPieces []string wantErr error }{ { input: \u0026#34;1.2.3.4\u0026#34;, wantPieces: []string{\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;, \u0026#34;4\u0026#34;}, }, { input: \u0026#34;hostname\u0026#34;, wantErr: ErrBadHostname, }, } 明确\ntests := []struct { input string wantIPv4 bool wantIPv6 bool wantErr bool }{ { input: \u0026#34;1.2.3.4\u0026#34;, wantIPv4: true, wantIPv6: false, }, { input: \u0026#34;1:2::3:4\u0026#34;, wantIPv4: false, wantIPv6: true, }, { input: \u0026#34;hostname\u0026#34;, wantIPv4: false, wantIPv6: false, wantErr: true, }, } Nil 切片 # 在大多数情况下，nil和空切片之间没有功能上的区别。像len和cap这样的内置函数在nil片上的表现与预期相同。\n// Good: import \u0026#34;fmt\u0026#34; var s []int // nil fmt.Println(s) // [] fmt.Println(len(s)) // 0 fmt.Println(cap(s)) // 0 for range s {...} // no-op s = append(s, 42) fmt.Println(s) // [42] 如果你声明一个空片作为局部变量（特别是如果它可以成为返回值的来源），最好选择nil初始化，以减少调用者的错误风险。\n// Good: var t []string // Bad: t := []string{} 不要创建强迫调用者区分nil和空片的API。\n// Good: // Ping pings its targets. // Returns hosts that successfully responded. func Ping(hosts []string) ([]string, error) { ... } // Bad: // Ping pings its targets and returns a list of hosts // that successfully responded. Can be empty if the input was empty. // nil signifies that a system error occurred. func Ping(hosts []string) []string { ... } 在设计接口时，避免区分 nil 切片和非 nil 的零长度分片，因为这可能导致微妙的编程错误。这通常是通过使用len来检查是否为空，而不是==nil来实现的。\n这个实现同时接受nil和零长度的片子为 \u0026ldquo;空\u0026rdquo;。\n// Good: // describeInts describes s with the given prefix, unless s is empty. func describeInts(prefix string, s []int) { if len(s) == 0 { return } fmt.Println(prefix, s) } 而不是依靠二者的区别作为API的一部分：\n// Bad: func maybeInts() []int { /* ... */ } // describeInts describes s with the given prefix; pass nil to skip completely. func describeInts(prefix string, s []int) { // The behavior of this function unintentionally changes depending on what // maybeInts() returns in \u0026#39;empty\u0026#39; cases (nil or []int{}). if s == nil { return } fmt.Println(prefix, s) } describeInts(\u0026#34;Here are some ints:\u0026#34;, maybeInts()) 详见 in-band 错误.\n缩进的混乱 # 如果断行会使其余的行与缩进的代码块对齐，则应避免引入断行。如果这是不可避免的，请留下一个空间，将代码块中的代码与包线分开。\n// Bad: if longCondition1 \u0026amp;\u0026amp; longCondition2 \u0026amp;\u0026amp; // Conditions 3 and 4 have the same indentation as the code within the if. longCondition3 \u0026amp;\u0026amp; longCondition4 { log.Info(\u0026#34;all conditions met\u0026#34;) } 具体准则和例子见以下章节：\nFunction formatting Conditionals and loops Literal formatting 函数格式化 # 函数或方法声明的签名应该保持在一行，以避免缩进的混乱。\n函数参数列表可以成为Go源文件中最长的几行。然而，它们在缩进的变化之前，因此很难以不使后续行看起来像函数体的一部分的方式来断行，从而造成混乱。\n// Bad: func (r *SomeType) SomeLongFunctionName(foo1, foo2, foo3 string, foo4, foo5, foo6 int) { foo7 := bar(foo1) // ... } 参见最佳实践，了解一些缩短函数调用的选择，否则这些函数会有很多参数。\n// Good: good := foo.Call(long, CallOptions{ Names: list, Of: of, The: parameters, Func: all, Args: on, Now: separate, Visible: lines, }) // Bad: bad := foo.Call( long, list, of, parameters, all, on, separate, lines, ) 通过分解局部变量，通常可以缩短行数。\n// Good: local := helper(some, parameters, here) good := foo.Call(list, of, parameters, local) Similarly, function and method calls should not be separated based solely on line length.\n// Good: good := foo.Call(long, list, of, parameters, all, on, one, line) // Bad: bad := foo.Call(long, list, of, parameters, with, arbitrary, line, breaks) Do not add comments to specific function parameters. Instead, use an option struct or add more detail to the function documentation.\n// Good: good := server.New(ctx, server.Options{Port: 42}) // Bad: bad := server.New( ctx, 42, // Port ) If call-sites are uncomfortably long, consider refactoring:\n// Good: // Sometimes variadic arguments can be factored out replacements := []string{ \u0026#34;from\u0026#34;, \u0026#34;to\u0026#34;, // related values can be formatted adjacent to one another \u0026#34;source\u0026#34;, \u0026#34;dest\u0026#34;, \u0026#34;original\u0026#34;, \u0026#34;new\u0026#34;, } // Use the replacement struct as inputs to NewReplacer. replacer := strings.NewReplacer(replacements...) If the API cannot be changed or if the local call is unusual (whether or not the call is too long), it is always permissible to add line breaks if it aids in understanding the call.\n// Good: canvas.RenderCube(cube, x0, y0, z0, x0, y0, z1, x0, y1, z0, x0, y1, z1, x1, y0, z0, x1, y0, z1, x1, y1, z0, x1, y1, z1, ) Note that the lines in the above example are not wrapped at a specific column boundary but are grouped based on co-ordinate triples.\nLong string literals within functions should not be broken for the sake of line length. For functions that include such strings, a line break can be added after the string format, and the arguments can be provided on the next or subsequent lines. The decision about where the line breaks should go is best made based on semantic groupings of inputs, rather than based purely on line length.\n// Good: log.Warningf(\u0026#34;Database key (%q, %d, %q) incompatible in transaction started by (%q, %d, %q)\u0026#34;, currentCustomer, currentOffset, currentKey, txCustomer, txOffset, txKey) // Bad: log.Warningf(\u0026#34;Database key (%q, %d, %q) incompatible in\u0026#34;+ \u0026#34; transaction started by (%q, %d, %q)\u0026#34;, currentCustomer, currentOffset, currentKey, txCustomer, txOffset, txKey) Conditionals and loops # An if statement should not be line broken; multi-line if clauses can lead to indentation confusion.\n// Bad: // The second if statement is aligned with the code within the if block, causing // indentation confusion. if db.CurrentStatusIs(db.InTransaction) \u0026amp;\u0026amp; db.ValuesEqual(db.TransactionKey(), row.Key()) { return db.Errorf(db.TransactionError, \u0026#34;query failed: row (%v): key does not match transaction key\u0026#34;, row) } If the short-circuit behavior is not required, the boolean operands can be extracted directly:\n// Good: inTransaction := db.CurrentStatusIs(db.InTransaction) keysMatch := db.ValuesEqual(db.TransactionKey(), row.Key()) if inTransaction \u0026amp;\u0026amp; keysMatch { return db.Error(db.TransactionError, \u0026#34;query failed: row (%v): key does not match transaction key\u0026#34;, row) } There may also be other locals that can be extracted, especially if the conditional is already repetitive:\n// Good: uid := user.GetUniqueUserID() if db.UserIsAdmin(uid) || db.UserHasPermission(uid, perms.ViewServerConfig) || db.UserHasPermission(uid, perms.CreateGroup) { // ... } // Bad: if db.UserIsAdmin(user.GetUniqueUserID()) || db.UserHasPermission(user.GetUniqueUserID(), perms.ViewServerConfig) || db.UserHasPermission(user.GetUniqueUserID(), perms.CreateGroup) { // ... } if statements that contain closures or multi-line struct literals should ensure that the braces match to avoid indentation confusion.\n// Good: if err := db.RunInTransaction(func(tx *db.TX) error { return tx.Execute(userUpdate, x, y, z) }); err != nil { return fmt.Errorf(\u0026#34;user update failed: %s\u0026#34;, err) } // Good: if _, err := client.Update(ctx, \u0026amp;upb.UserUpdateRequest{ ID: userID, User: user, }); err != nil { return fmt.Errorf(\u0026#34;user update failed: %s\u0026#34;, err) } Similarly, don’t try inserting artificial linebreaks into for statements. You can always let the line simply be long if there is no elegant way to refactor it:\n// Good: for i, max := 0, collection.Size(); i \u0026lt; max \u0026amp;\u0026amp; !collection.HasPendingWriters(); i++ { // ... } Often, though, there is:\n// Good: for i, max := 0, collection.Size(); i \u0026lt; max; i++ { if collection.HasPendingWriters() { break } // ... } switch and case statements should also remain on a single line.\n// Good: switch good := db.TransactionStatus(); good { case db.TransactionStarting, db.TransactionActive, db.TransactionWaiting: // ... case db.TransactionCommitted, db.NoTransaction: // ... default: // ... } // Bad: switch bad := db.TransactionStatus(); bad { case db.TransactionStarting, db.TransactionActive, db.TransactionWaiting: // ... case db.TransactionCommitted, db.NoTransaction: // ... default: // ... } If the line is excessively long, indent all cases and separate them with a blank line to avoid indentation confusion:\n// Good: switch db.TransactionStatus() { case db.TransactionStarting, db.TransactionActive, db.TransactionWaiting, db.TransactionCommitted: // ... case db.NoTransaction: // ... default: // ... } In conditionals comparing a variable to a constant, place the variable value on the left hand side of the equality operator:\n// Good: if result == \u0026#34;foo\u0026#34; { // ... } Instead of the less clear phrasing where the constant comes first (“Yoda style conditionals”):\n// Bad: if \u0026#34;foo\u0026#34; == result { // ... } Copying # To avoid unexpected aliasing and similar bugs, be careful when copying a struct from another package. For example, synchronization objects such as sync.Mutex must not be copied.\nThe bytes.Buffer type contains a []byte slice and, as an optimization for small strings, a small byte array to which the slice may refer. If you copy a Buffer, the slice in the copy may alias the array in the original, causing subsequent method calls to have surprising effects.\nIn general, do not copy a value of type T if its methods are associated with the pointer type, *T.\n// Bad: b1 := bytes.Buffer{} b2 := b1 Invoking a method that takes a value receiver can hide the copy. When you author an API, you should generally take and return pointer types if your structs contain fields that should not be copied.\nThese are acceptable:\n// Good: type Record struct { buf bytes.Buffer // other fields omitted } func New() *Record {...} func (r *Record) Process(...) {...} func Consumer(r *Record) {...} But these are usually wrong:\n// Bad: type Record struct { buf bytes.Buffer // other fields omitted } func (r Record) Process(...) {...} // Makes a copy of r.buf func Consumer(r Record) {...} // Makes a copy of r.buf This guidance also applies to copying sync.Mutex.\nDon’t panic # Do not use panic for normal error handling. Instead, use error and multiple return values. See the Effective Go section on errors.\nWithin package main and initialization code, consider log.Exit for errors that should terminate the program (e.g., invalid configuration), as in many of these cases a stack trace will not help the reader. Please note that log.Exit calls os.Exit and any deferred functions will not be run.\nFor errors that indicate “impossible” conditions, namely bugs that should always be caught during code review and/or testing, a function may reasonably return an error or call log.Fatal.\nNote: log.Fatalf is not the standard library log. See [#logging].\nMust functions # Setup helper functions that stop the program on failure follow the naming convention MustXYZ (or mustXYZ). In general, they should only be called early on program startup, not on things like user input where normal Go error handling is preferred.\nThis often comes up for functions called to initialize package-level variables exclusively at package initialization time (e.g. template.Must and regexp.MustCompile).\n// Good: func MustParse(version string) *Version { v, err := Parse(version) if err != nil { log.Fatalf(\u0026#34;MustParse(%q) = _, %v\u0026#34;, version, err) } return v } // Package level \u0026#34;constant\u0026#34;. If we wanted to use `Parse`, we would have had to // set the value in `init`. var DefaultVersion = MustParse(\u0026#34;1.2.3\u0026#34;) Note: log.Fatalf is not the standard library log. See [#logging].\nThe same convention may be used in test helpers that only stop the current test (using t.Fatal). Such helpers are often convenient in creating test values, for example in struct fields of table driven tests, as functions that return errors cannot be directly assigned to a struct field.\n// Good: func mustMarshalAny(t *testing.T, m proto.Message) *anypb.Any { t.Helper() any, err := anypb.New(m) if err != nil { t.Fatalf(\u0026#34;MustMarshalAny(t, m) = %v; want %v\u0026#34;, err, nil) } return any } func TestCreateObject(t *testing.T) { tests := []struct{ desc string data *anypb.Any }{ { desc: \u0026#34;my test case\u0026#34;, // Creating values directly within table driven test cases. data: mustMarshalAny(t, mypb.Object{}), }, // ... } // ... } In both of these cases, the value of this pattern is that the helpers can be called in a “value” context. These helpers should not be called in places where it’s difficult to ensure an error would be caught or in a context where an error should be checked (e.g., in many request handlers). For constant inputs, this allows tests to easily ensure that the Must arguments are well-formed, and for non-constant inputs it permits tests to validate that errors are properly handled or propagated.\nWhere Must functions are used in a test, they should generally be marked as a test helper and call t.Fatal on error (see error handling in test helpers for more considerations of using that).\nThey should not be used when ordinary error handling is possible (including with some refactoring):\n// Bad: func Version(o *servicepb.Object) (*version.Version, error) { // Return error instead of using Must functions. v := version.MustParse(o.GetVersionString()) return dealiasVersion(v) } Goroutine lifetimes # When you spawn goroutines, make it clear when or whether they exit.\nGoroutines can leak by blocking on channel sends or receives. The garbage collector will not terminate a goroutine even if the channels it is blocked on are unreachable.\nEven when goroutines do not leak, leaving them in-flight when they are no longer needed can cause other subtle and hard-to-diagnose problems. Sending on a channel that has been closed causes a panic.\n// Bad: ch := make(chan int) ch \u0026lt;- 42 close(ch) ch \u0026lt;- 13 // panic Modifying still-in-use inputs “after the result isn’t needed” can lead to data races. Leaving goroutines in-flight for arbitrarily long can lead to unpredictable memory usage.\nConcurrent code should be written such that the goroutine lifetimes are obvious. Typically this will mean keeping synchronization-related code constrained within the scope of a function and factoring out the logic into synchronous functions. If the concurrency is still not obvious, it is important to document when and why the goroutines exit.\nCode that follows best practices around context usage often helps make this clear. It is conventionally managed with a context.Context:\n// Good: func (w *Worker) Run(ctx context.Context) error { // ... for item := range w.q { // process returns at latest when the context is cancelled. go process(ctx, item) } // ... } There are other variants of the above that use raw signal channels like chan struct{}, synchronized variables, condition variables, and more. The important part is that the goroutine’s end is evident for subsequent maintainers.\nIn contrast, the following code is careless about when its spawned goroutines finish:\n// Bad: func (w *Worker) Run() { // ... for item := range w.q { // process returns when it finishes, if ever, possibly not cleanly // handling a state transition or termination of the Go program itself. go process(item) } // ... } This code may look OK, but there are several underlying problems:\nThe code probably has undefined behavior in production, and the program may not terminate cleanly, even if the operating system releases the resources. The code is difficult to test meaningfully due to the code’s indeterminate lifecycle. The code may leak resources as described above. See also:\nNever start a goroutine without knowing how it will stop Rethinking Classical Concurrency Patterns: slides, video When Go programs end Interfaces # Go interfaces generally belong in the package that consumes values of the interface type, not a package that implements the interface type. The implementing package should return concrete (usually pointer or struct) types. That way, new methods can be added to implementations without requiring extensive refactoring. See GoTip #49: Accept Interfaces, Return Concrete Types for more details.\nDo not export a test double implementation of an interface from an API that consumes it. Instead, design the API so that it can be tested using the public API of the real implementation. See GoTip #42: Authoring a Stub for Testing for more details. Even when it is not feasible to use the real implementation, it may not be necessary to introduce an interface fully covering all methods in the real type; the consumer can create an interface containing only the methods it needs, as demonstrated in GoTip #78: Minimal Viable Interfaces.\nTo test packages that use Stubby RPC clients, use a real client connection. If a real server cannot be run in the test, Google’s internal practice is to obtain a real client connection to a local [test double] using the internal rpctest package (coming soon!).\nDo not define interfaces before they are used (see TotT: Code Health: Eliminate YAGNI Smells ). Without a realistic example of usage, it is too difficult to see whether an interface is even necessary, let alone what methods it should contain.\nDo not use interface-typed parameters if the users of the package do not need to pass different types for them.\nDo not export interfaces that the users of the package do not need.\nTODO: Write a more in-depth doc on interfaces and link to it here.\n// Good: package consumer // consumer.go type Thinger interface { Thing() bool } func Foo(t Thinger) string { ... } // Good: package consumer // consumer_test.go type fakeThinger struct{ ... } func (t fakeThinger) Thing() bool { ... } ... if Foo(fakeThinger{...}) == \u0026#34;x\u0026#34; { ... } // Bad: package producer type Thinger interface { Thing() bool } type defaultThinger struct{ ... } func (t defaultThinger) Thing() bool { ... } func NewThinger() Thinger { return defaultThinger{ ... } } // Good: package producer type Thinger struct{ ... } func (t Thinger) Thing() bool { ... } func NewThinger() Thinger { return Thinger{ ... } } Generics # Generics (formally called “Type Parameters”) are allowed where they fulfill your business requirements. In many applications, a conventional approach using existing language features (slices, maps, interfaces, and so on) works just as well without the added complexity, so be wary of premature use. See the discussion on least mechanism.\nWhen introducing an exported API that uses generics, make sure it is suitably documented. It’s highly encouraged to include motivating runnable examples.\nDo not use generics just because you are implementing an algorithm or data structure that does not care about the type of its member elements. If there is only one type being instantiated in practice, start by making your code work on that type without using generics at all. Adding polymorphism later will be straightforward compared to removing abstraction that is found to be unnecessary.\nDo not use generics to invent domain-specific languages (DSLs). In particular, refrain from introducing error-handling frameworks that might put a significant burden on readers. Instead prefer established error handling practices. For testing, be especially wary of introducing assertion libraries or frameworks that result in less useful test failures.\nIn general:\nWrite code, don’t design types. From a GopherCon talk by Robert Griesemer and Ian Lance Taylor. If you have several types that share a useful unifying interface, consider modeling the solution using that interface. Generics may not be needed. Otherwise, instead of relying on the any type and excessive type switching, consider generics. See also:\nUsing Generics in Go, talk by Ian Lance Taylor Generics tutorial on Go’s webpage Pass values # Do not pass pointers as function arguments just to save a few bytes. If a function reads its argument x only as *x throughout, then the argument shouldn’t be a pointer. Common instances of this include passing a pointer to a string (*string) or a pointer to an interface value (*io.Reader). In both cases, the value itself is a fixed size and can be passed directly.\nThis advice does not apply to large structs, or even small structs that may increase in size. In particular, protocol buffer messages should generally be handled by pointer rather than by value. The pointer type satisfies the proto.Message interface (accepted by proto.Marshal, protocmp.Transform, etc.), and protocol buffer messages can be quite large and often grow larger over time.\nReceiver type # A method receiver can be passed either as a value or a pointer, just as if it were a regular function parameter. The choice of which to choose should be based on which method set(s) the method should be a part of.\nCorrectness wins over speed or simplicity. There are cases where you must use a pointer value. In other cases, pick pointers for large types or as future-proofing if you don’t have a good sense of how the code will grow, and use values for simple plain old data.\nThe list below spells out each case in further detail:\nIf the receiver is a slice and the method doesn’t reslice or reallocate the slice, use a value rather than a pointer.\n// Good: type Buffer []byte func (b Buffer) Len() int { return len(b) } If the method needs to mutate the receiver, the receiver must be a pointer.\n// Good: type Counter int func (c *Counter) Inc() { *c++ } // See https://pkg.go.dev/container/heap. type Queue []Item func (q *Queue) Push(x Item) { *q = append([]Item{x}, *q...) } If the receiver is a struct containing fields that cannot safely be copied, use a pointer receiver. Common examples are sync.Mutex and other synchronization types.\n// Good: type Counter struct { mu sync.Mutex total int } func (c *Counter) Inc() { c.mu.Lock() defer c.mu.Unlock() c.total++ } Tip: Check the type’s Godoc for information about whether it is safe or unsafe to copy.\nIf the receiver is a “large” struct or array, a pointer receiver may be more efficient. Passing a struct is equivalent to passing all of its fields or elements as arguments to the method. If that seems too large to pass by value, a pointer is a good choice.\nFor methods that will call or run concurrently with other functions that modify the receiver, use a value if those modifications should not be visible to your method; otherwise use a pointer.\nIf the receiver is a struct or array, any of whose elements is a pointer to something that may be mutated, prefer a pointer receiver to make the intention of mutability clear to the reader.\n// Good: type Counter struct { m *Metric } func (c *Counter) Inc() { c.m.Add(1) } If the receiver is a built-in type, such as an integer or a string, that does not need to be modified, use a value.\n// Good: type User string func (u User) String() { return string(u) } If the receiver is a map, function, or channel, use a value rather than a pointer.\n// Good: // See https://pkg.go.dev/net/http#Header. type Header map[string][]string func (h Header) Add(key, value string) { /* omitted */ } If the receiver is a “small” array or struct that is naturally a value type with no mutable fields and no pointers, a value receiver is usually the right choice.\n// Good: // See https://pkg.go.dev/time#Time. type Time struct { /* omitted */ } func (t Time) Add(d Duration) Time { /* omitted */ } When in doubt, use a pointer receiver.\nAs a general guideline, prefer to make the methods for a type either all pointer methods or all value methods.\nNote: There is a lot of misinformation about whether passing a value or a pointer to a function can affect performance. The compiler can choose to pass pointers to values on the stack as well as copying values on the stack, but these considerations should not outweigh the readability and correctness of the code in most circumstances. When the performance does matter, it is important to profile both approaches with a realistic benchmark before deciding that one approach outperforms the other.\nswitch and break # Do not use break statements without target labels at the ends of switch clauses; they are redundant. Unlike in C and Java, switch clauses in Go automatically break, and a fallthrough statement is needed to achieve the C-style behavior. Use a comment rather than break if you want to clarify the purpose of an empty clause.\n// Good: switch x { case \u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;: buf.WriteString(x) case \u0026#34;C\u0026#34;: // handled outside of the switch statement default: return fmt.Errorf(\u0026#34;unknown value: %q\u0026#34;, x) } // Bad: switch x { case \u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;: buf.WriteString(x) break // this break is redundant case \u0026#34;C\u0026#34;: break // this break is redundant default: return fmt.Errorf(\u0026#34;unknown value: %q\u0026#34;, x) } Note: If a switch clause is within a for loop, using break within switch does not exit the enclosing for loop.\nfor { switch x { case \u0026#34;A\u0026#34;: break // exits the switch, not the loop } } To escape the enclosing loop, use a label on the for statement:\nloop: for { switch x { case \u0026#34;A\u0026#34;: break loop // exits the loop } } Synchronous functions # Synchronous functions return their results directly and finish any callbacks or channel operations before returning. Prefer synchronous functions over asynchronous functions.\nSynchronous functions keep goroutines localized within a call. This helps to reason about their lifetimes, and avoid leaks and data races. Synchronous functions are also easier to test, since the caller can pass an input and check the output without the need for polling or synchronization.\nIf necessary, the caller can add concurrency by calling the function in a separate goroutine. However, it is quite difficult (sometimes impossible) to remove unnecessary concurrency at the caller side.\nSee also:\n“Rethinking Classical Concurrency Patterns”, talk by Bryan Mills: slides, video Type aliases # Use a type definition, type T1 T2, to define a new type. Use a type alias, type T1 = T2, to refer to an existing type without defining a new type. Type aliases are rare; their primary use is to aid migrating packages to new source code locations. Don’t use type aliasing when it is not needed.\nUse %q # Go’s format functions (fmt.Printf etc.) have a %q verb which prints strings inside double-quotation marks.\n// Good: fmt.Printf(\u0026#34;value %q looks like English text\u0026#34;, someText) Prefer using %q over doing the equivalent manually, using %s:\n// Bad: fmt.Printf(\u0026#34;value \\\u0026#34;%s\\\u0026#34; looks like English text\u0026#34;, someText) // Avoid manually wrapping strings with single-quotes too: fmt.Printf(\u0026#34;value \u0026#39;%s\u0026#39; looks like English text\u0026#34;, someText) Using %q is recommended in output intended for humans where the input value could possibly be empty or contain control characters. It can be very hard to notice a silent empty string, but \u0026quot;\u0026quot; stands out clearly as such.\nUse any # Go 1.18 introduces an any type as an alias to interface{}. Because it is an alias, any is equivalent to interface{} in many situations and in others it is easily interchangeable via an explicit conversion. Prefer to use any in new code.\nCommon libraries # Flags # Go programs in the Google codebase use an internal variant of the standard flag package. It has a similar interface but interoperates well with internal Google systems. Flag names in Go binaries should prefer to use underscores to separate words, though the variables that hold a flag’s value should follow the standard Go name style (mixed caps). Specifically, the flag name should be in snake case, and the variable name should be the equivalent name in camel case.\n// Good: var ( pollInterval = flag.Duration(\u0026#34;poll_interval\u0026#34;, time.Minute, \u0026#34;Interval to use for polling.\u0026#34;) ) // Bad: var ( poll_interval = flag.Int(\u0026#34;pollIntervalSeconds\u0026#34;, 60, \u0026#34;Interval to use for polling in seconds.\u0026#34;) ) Flags must only be defined in package main or equivalent.\nGeneral-purpose packages should be configured using Go APIs, not by punching through to the command-line interface; don’t let importing a library export new flags as a side effect. That is, prefer explicit function arguments or struct field assignment or much less frequently and under the strictest of scrutiny exported global variables. In the extremely rare case that it is necessary to break this rule, the flag name must clearly indicate the package that it configures.\nIf your flags are global variables, place them in their own var group, following the imports section.\nThere is additional discussion around best practices for creating complex CLIs with subcommands.\nSee also:\nTip of the Week #45: Avoid Flags, Especially in Library Code Go Tip #10: Configuration Structs and Flags Go Tip #80: Dependency Injection Principles Logging # Go programs in the Google codebase use a variant of the standard log package. It has a similar but more powerful interface and interoperates well with internal Google systems. An open source version of this library is available as package glog, and open source Google projects may use that, but this guide refers to it as log throughout.\nNote: For abnormal program exits, this library uses log.Fatal to abort with a stacktrace, and log.Exit to stop without one. There is no log.Panic function as in the standard library.\nTip: log.Info(v) is equivalent log.Infof(\u0026quot;%v\u0026quot;, v), and the same goes for other logging levels. Prefer the non-formatting version when you have no formatting to do.\nSee also:\nBest practices on logging errors and custom verbosily levels When and how to use the log package to stop the program Contexts # Values of the context.Context type carry security credentials, tracing information, deadlines, and cancellation signals across API and process boundaries. Unlike C++ and Java, which in the Google codebase use thread-local storage, Go programs pass contexts explicitly along the entire function call chain from incoming RPCs and HTTP requests to outgoing requests.\nWhen passed to a function or method, context.Context is always the first parameter.\nfunc F(ctx context.Context /* other arguments */) {} Exceptions are:\nIn an HTTP handler, where the context comes from req.Context().\nIn streaming RPC methods, where the context comes from the stream.\nCode using gRPC streaming accesses a context from a Context() method in the generated server type, which implements grpc.ServerStream. See https://grpc.io/docs/languages/go/generated-code/.\nIn entrypoint functions (see below for examples of such functions), use context.Background().\nIn binary targets: main In general purpose code and libraries: init In tests: TestXXX, BenchmarkXXX, FuzzXXX Note: It is very rare for code in the middle of a callchain to require creating a base context of its own using context.Background(). Always prefer taking a context from your caller, unless it’s the wrong context.\nYou may come across server libraries (the implementation of Stubby, gRPC, or HTTP in Google’s server framework for Go) that construct a fresh context object per request. These contexts are immediately filled with information from the incoming request, so that when passed to the request handler, the context’s attached values have been propagated to it across the network boundary from the client caller. Moreover, these contexts’ lifetimes are scoped to that of the request: when the request is finished, the context is cancelled.\nUnless you are implementing a server framework, you shouldn’t create contexts with context.Background() in library code. Instead, prefer using context detachment, which is mentioned below, if there is an existing context available. If you think you do need context.Background() outside of entrypoint functions, discuss it with the Google Go style mailing list before committing to an implementation.\nThe convention that context.Context comes first in functions also applies to test helpers.\n// Good: func readTestFile(ctx context.Context, t *testing.T, path string) string {} Do not add a context member to a struct type. Instead, add a context parameter to each method on the type that needs to pass it along. The one exception is for methods whose signature must match an interface in the standard library or in a third party library outside Google’s control. Such cases are very rare, and should be discussed with the Google Go style mailing list before implementation and readability review.\nCode in the Google codebase that must spawn background operations which can run after the parent context has been cancelled can use an internal package for detachment. Follow https://github.com/golang/go/issues/40221 for discussions on an open source alternative.\nSince contexts are immutable, it is fine to pass the same context to multiple calls that share the same deadline, cancellation signal, credentials, parent trace, and so on.\nSee also:\nContexts and structs Custom contexts # Do not create custom context types or use interfaces other than context in function signatures. There are no exceptions to this rule.\nImagine if every team had a custom context. Every function call from package P to package Q would have to determine how to convert a PContext to a QContext, for all pairs of packages P and Q. This is impractical and error-prone for humans, and it makes automated refactorings that add context parameters nearly impossible.\nIf you have application data to pass around, put it in a parameter, in the receiver, in globals, or in a Context value if it truly belongs there. Creating your own Context type is not acceptable since it undermines the ability of the Go team to make Go programs work properly in production.\ncrypto/rand # Do not use package math/rand to generate keys, even throwaway ones. If unseeded, the generator is completely predictable. Seeded with time.Nanoseconds(), there are just a few bits of entropy. Instead, use crypto/rand’s Reader, and if you need text, print to hexadecimal or base64.\n// Good: import ( \u0026#34;crypto/rand\u0026#34; // \u0026#34;encoding/base64\u0026#34; // \u0026#34;encoding/hex\u0026#34; \u0026#34;fmt\u0026#34; // ... ) func Key() string { buf := make([]byte, 16) if _, err := rand.Read(buf); err != nil { log.Fatalf(\u0026#34;Out of randomness, should never happen: %v\u0026#34;, err) } return fmt.Sprintf(\u0026#34;%x\u0026#34;, buf) // or hex.EncodeToString(buf) // or base64.StdEncoding.EncodeToString(buf) } Note: log.Fatalf is not the standard library log. See [#logging].\nUseful test failures # It should be possible to diagnose a test’s failure without reading the test’s source. Tests should fail with helpful messages detailing:\nWhat caused the failure What inputs resulted in an error The actual result What was expected Specific conventions for achieving this goal are outlined below.\nAssertion libraries # Do not create “assertion libraries” as helpers for testing.\nAssertion libraries are libraries that attempt to combine the validation and production of failure messages within a test (though the same pitfalls can apply to other test helpers as well). For more on the distinction between test helpers and assertion libraries, see best practices.\n// Bad: var obj BlogPost assert.IsNotNil(t, \u0026#34;obj\u0026#34;, obj) assert.StringEq(t, \u0026#34;obj.Type\u0026#34;, obj.Type, \u0026#34;blogPost\u0026#34;) assert.IntEq(t, \u0026#34;obj.Comments\u0026#34;, obj.Comments, 2) assert.StringNotEq(t, \u0026#34;obj.Body\u0026#34;, obj.Body, \u0026#34;\u0026#34;) Assertion libraries tend to either stop the test early (if assert calls t.Fatalf or panic) or omit relevant information about what the test got right:\n// Bad: package assert func IsNotNil(t *testing.T, name string, val interface{}) { if val == nil { t.Fatalf(\u0026#34;data %s = nil, want not nil\u0026#34;, name) } } func StringEq(t *testing.T, name, got, want string) { if got != want { t.Fatalf(\u0026#34;data %s = %q, want %q\u0026#34;, name, got, want) } } Complex assertion functions often do not provide useful failure messages and context that exists within the test function. Too many assertion functions and libraries lead to a fragmented developer experience: which assertion library should I use, what style of output format should it emit, etc.? Fragmentation produces unnecessary confusion, especially for library maintainers and authors of large-scale changes, who are responsible for fixing potential downstream breakages. Instead of creating a domain-specific language for testing, use Go itself.\nAssertion libraries often factor out comparisons and equality checks. Prefer using standard libraries such as cmp and fmt instead:\n// Good: var got BlogPost want := BlogPost{ Comments: 2, Body: \u0026#34;Hello, world!\u0026#34;, } if !cmp.Equal(got, want) { t.Errorf(\u0026#34;blog post = %v, want = %v\u0026#34;, got, want) } For more domain-specific comparison helpers, prefer returning a value or an error that can be used in the test’s failure message instead of passing *testing.T and calling its error reporting methods:\n// Good: func postLength(p BlogPost) int { return len(p.Body) } func TestBlogPost_VeritableRant(t *testing.T) { post := BlogPost{Body: \u0026#34;I am Gunnery Sergeant Hartman, your senior drill instructor.\u0026#34;} if got, want := postLength(post), 60; got != want { t.Errorf(\u0026#34;length of post = %v, want %v\u0026#34;, got, want) } } Best Practice: Were postLength non-trivial, it would make sense to test it directly, independently of any tests that use it.\nSee also:\nEquality comparison and diffs Print diffs For more on the distinction between test helpers and assertion helpers, see best practices Identify the function # In most tests, failure messages should include the name of the function that failed, even though it seems obvious from the name of the test function. Specifically, your failure message should be YourFunc(%v) = %v, want %v instead of just got %v, want %v.\nIdentify the input # In most tests, failure messages should include the function inputs if they are short. If the relevant properties of the inputs are not obvious (for example, because the inputs are large or opaque), you should name your test cases with a description of what’s being tested and print the description as part of your error message.\nGot before want # Test outputs should include the actual value that the function returned before printing the value that was expected. A standard format for printing test outputs is YourFunc(%v) = %v, want %v. Where you would write “actual” and “expected”, prefer using the words “got” and “want”, respectively.\nFor diffs, directionality is less apparent, and as such it is important to include a key to aid in interpreting the failure. See the section on printing diffs. Whichever diff order you use in your failure messages, you should explicitly indicate it as a part of the failure message, because existing code is inconsistent about the ordering.\nFull structure comparisons # If your function returns a struct (or any data type with multiple fields such as slices, arrays, and maps), avoid writing test code that performs a hand-coded field-by-field comparison of the struct. Instead, construct the data that you’re expecting your function to return, and compare directly using a deep comparison.\nNote: This does not apply if your data contains irrelevant fields that obscure the intention of the test.\nIf your struct needs to be compared for approximate (or equivalent kind of semantic) equality or it contains fields that cannot be compared for equality (e.g., if one of the fields is an io.Reader), tweaking a cmp.Diff or cmp.Equal comparison with cmpopts options such as cmpopts.IgnoreInterfaces may meet your needs (example).\nIf your function returns multiple return values, you don’t need to wrap those in a struct before comparing them. Just compare the return values individually and print them.\n// Good: val, multi, tail, err := strconv.UnquoteChar(`\\\u0026#34;Fran \u0026amp; Freddie\u0026#39;s Diner\\\u0026#34;`, \u0026#39;\u0026#34;\u0026#39;) if err != nil { t.Fatalf(...) } if val != `\u0026#34;` { t.Errorf(...) } if multi { t.Errorf(...) } if tail != `Fran \u0026amp; Freddie\u0026#39;s Diner\u0026#34;` { t.Errorf(...) } Compare stable results # Avoid comparing results that may depend on output stability of a package that you do not own. Instead, the test should compare on semantically relevant information that is stable and resistant to changes in dependencies. For functionality that returns a formatted string or serialized bytes, it is generally not safe to assume that the output is stable.\nFor example, json.Marshal can change (and has changed in the past) the specific bytes that it emits. Tests that perform string equality on the JSON string may break if the json package changes how it serializes the bytes. Instead, a more robust test would parse the contents of the JSON string and ensure that it is semantically equivalent to some expected data structure.\nKeep going # Tests should keep going for as long as possible, even after a failure, in order to print out all of the failed checks in a single run. This way, a developer who is fixing the failing test doesn’t have to re-run the test after fixing each bug to find the next bug.\nPrefer calling t.Error over t.Fatal for reporting a mismatch. When comparing several different properties of a function’s output, use t.Error for each of those comparisons.\nCalling t.Fatal is primarily useful for reporting an unexpected error condition, when subsequent comparison failures are not going to be meaningful.\nFor table-driven test, consider using subtests and use t.Fatal rather than t.Error and continue. See also GoTip #25: Subtests: Making Your Tests Lean.\nBest practice: For more discussion about when t.Fatal should be used, see best practices.\nEquality comparison and diffs # The == operator evaluates equality using language-defined comparisons. Scalar values (numbers, booleans, etc) are compared based on their values, but only some structs and interfaces can be compared in this way. Pointers are compared based on whether they point to the same variable, rather than based on the equality of the values to which they point.\nThe cmp package can compare more complex data structures not appropriately handled by ==, such as slices. Use cmp.Equal for equality comparison and cmp.Diff to obtain a human-readable diff between objects.\n// Good: want := \u0026amp;Doc{ Type: \u0026#34;blogPost\u0026#34;, Comments: 2, Body: \u0026#34;This is the post body.\u0026#34;, Authors: []string{\u0026#34;isaac\u0026#34;, \u0026#34;albert\u0026#34;, \u0026#34;emmy\u0026#34;}, } if !cmp.Equal(got, want) { t.Errorf(\u0026#34;AddPost() = %+v, want %+v\u0026#34;, got, want) } As a general-purpose comparison library, cmp may not know how to compare certain types. For example, it can only compare protocol buffer messages if passed the protocmp.Transform option.\n// Good: if diff := cmp.Diff(want, got, protocmp.Transform()); diff != \u0026#34;\u0026#34; { t.Errorf(\u0026#34;Foo() returned unexpected difference in protobuf messages (-want +got):\\n%s\u0026#34;, diff) } Although the cmp package is not part of the Go standard library, it is maintained by the Go team and should produce stable equality results over time. It is user-configurable and should serve most comparison needs.\nExisting code may make use of the following older libraries, and may continue using them for consistency:\npretty produces aesthetically pleasing difference reports. However, it quite deliberately considers values that have the same visual representation as equal. In particular, pretty does not catch differences between nil slices and empty ones, is not sensitive to different interface implementations with identical fields, and it is possible to use a nested map as the basis for comparison with a struct value. It also serializes the entire value into a string before producing a diff, and as such is not a good choice for comparing large values. By default, it compares unexported fields, which makes it sensitive to changes in implementation details in your dependencies. For this reason, it is not appropriate to use pretty on protobuf messages. Prefer using cmp for new code, and it is worth considering updating older code to use cmp where and when it is practical to do so.\nOlder code may use the standard library reflect.DeepEqual function to compare complex structures. reflect.DeepEqual should not be used for checking equality, as it is sensitive to changes in unexported fields and other implementation details. Code that is using reflect.DeepEqual should be updated to one of the above libraries.\nNote: The cmp package is designed for testing, rather than production use. As such, it may panic when it suspects that a comparison is performed incorrectly to provide instruction to users on how to improve the test to be less brittle. Given cmp’s propensity towards panicking, it makes it unsuitable for code that is used in production as a spurious panic may be fatal.\nLevel of detail # The conventional failure message, which is suitable for most Go tests, is YourFunc(%v) = %v, want %v. However, there are cases that may call for more or less detail:\nTests performing complex interactions should describe the interactions too. For example, if the same YourFunc is called several times, identify which call failed the test. If it’s important to know any extra state of the system, include that in the failure output (or at least in the logs). If the data is a complex struct with significant boilerplate, it is acceptable to describe only the important parts in the message, but do not overly obscure the data. Setup failures do not require the same level of detail. If a test helper populates a Spanner table but Spanner was down, you probably don’t need to include which test input you were going to store in the database. t.Fatalf(\u0026quot;Setup: Failed to set up test database: %s\u0026quot;, err) is usually helpful enough to resolve the issue. Tip: Make your failure mode trigger during development. Review what the failure message looks like and whether a maintainer can effectively deal with the failure.\nThere are some techniques for reproducing test inputs and outputs clearly:\nWhen printing string data, %q is often useful to emphasize that the value is important and to more easily spot bad values. When printing (small) structs, %+v can be more useful than %v. When validation of larger values fails, printing a diff can make it easier to understand the failure. Print diffs # If your function returns large output then it can be hard for someone reading the failure message to find the differences when your test fails. Instead of printing both the returned value and the wanted value, make a diff.\nTo compute diffs for such values, cmp.Diff is preferred, particularly for new tests and new code, but other tools may be used. See types of equality for guidance regarding the strengths and weaknesses of each function.\ncmp.Diff pretty.Compare You can use the diff package to compare multi-line strings or lists of strings. You can use this as a building block for other kinds of diffs.\nAdd some text to your failure message explaining the direction of the diff.\nSomething like diff (-want +got) is good when you’re using the cmp, pretty, and diff packages (if you pass (want, got) to the function), because the - and + that you add to your format string will match the - and + that actually appear at the beginning of the diff lines. If you pass (got, want) to your function, the correct key would be (-got +want) instead. The messagediff package uses a different output format, so the message diff (want -\u0026gt; got) is appropriate when you’re using it (if you pass (want, got) to the function), because the direction of the arrow will match the direction of the arrow in the “modified” lines. The diff will span multiple lines, so you should print a newline before you print the diff.\nTest error semantics # When a unit test performs string comparisons or uses a vanilla cmp to check that particular kinds of errors are returned for particular inputs, you may find that your tests are brittle if any of those error messages are reworded in the future. Since this has the potential to turn your unit test into a change detector (see TotT: Change-Detector Tests Considered Harmful ), don’t use string comparison to check what type of error your function returns. However, it is permissible to use string comparisons to check that error messages coming from the package under test satisfy certain properties, for example, that it includes the parameter name.\nError values in Go typically have a component intended for human eyes and a component intended for semantic control flow. Tests should seek to only test semantic information that can be reliably observed, rather than display information that is intended for human debugging, as this is often subject to future changes. For guidance on constructing errors with semantic meaning see best-practices regarding errors. If an error with insufficient semantic information is coming from a dependency outside your control, consider filing a bug against the owner to help improve the API, rather than relying on parsing the error message.\nWithin unit tests, it is common to only care whether an error occurred or not. If so, then it is sufficient to only test whether the error was non-nil when you expected an error. If you would like to test that the error semantically matches some other error, then consider using cmp with cmpopts.EquateErrors.\nNote: If a test uses cmpopts.EquateErrors but all of its wantErr values are either nil or cmpopts.AnyError, then using cmp is unnecessary mechanism. Simplify the code by making the want field a bool. You can then use a simple comparison with !=.\n// Good: gotErr := f(test.input) != nil if gotErr != test.wantErr { t.Errorf(\u0026#34;f(%q) returned err = %v, want error presence = %v\u0026#34;, test.input, gotErr, test.wantErr) } See also GoTip #13: Designing Errors for Checking.\nTest structure # Subtests # The standard Go testing library offers a facility to define subtests. This allows flexibility in setup and cleanup, controlling parallelism, and test filtering. Subtests can be useful (particularly for table-driven tests), but using them is not mandatory. See also https://blog.golang.org/subtests.\nSubtests should not depend on the execution of other cases for success or initial state, because subtests are expected to be able to be run individually with using go test -run flags or with Bazel test filter expressions.\nSubtest names # Name your subtest such that it is readable in test output and useful on the command line for users of test filtering. When you use t.Run to create a subtest, the first argument is used as a descriptive name for the test. To ensure that test results are legible to humans reading the logs, choose subtest names that will remain useful and readable after escaping. Think of subtest names more like a function identifier than a prose description. The test runner replaces spaces with underscores, and escapes non-printing characters. If your test data benefits from a longer description, consider putting the description in a separate field (perhaps to be printed using t.Log or alongside failure messages).\nSubtests may be run individually using flags to the Go test runner or Bazel test filter, so choose descriptive names that are also easy to type.\nWarning: Slash characters are particularly unfriendly in subtest names, since they have [special meaning for test filters](https://blog.golang.org/subtests#:~:text=Perhaps a bit,match any tests).\n# Bad: # Assuming TestTime and t.Run(\u0026#34;America/New_York\u0026#34;, ...) bazel test :mytest --test_filter=\u0026#34;Time/New_York\u0026#34; # Runs nothing! bazel test :mytest --test_filter=\u0026#34;Time//New_York\u0026#34; # Correct, but awkward. To identify the inputs of the function, include them in the test’s failure messages, where they won’t be escaped by the test runner.\n// Good: func TestTranslate(t *testing.T) { data := []struct { name, desc, srcLang, dstLang, srcText, wantDstText string }{ { name: \u0026#34;hu=en_bug-1234\u0026#34;, desc: \u0026#34;regression test following bug 1234. contact: cleese\u0026#34;, srcLang: \u0026#34;hu\u0026#34;, srcText: \u0026#34;cigarettát és egy öngyújtót kérek\u0026#34;, dstLang: \u0026#34;en\u0026#34;, wantDstText: \u0026#34;cigarettes and a lighter please\u0026#34;, }, // ... } for _, d := range data { t.Run(d.name, func(t *testing.T) { got := Translate(d.srcLang, d.dstLang, d.srcText) if got != d.wantDstText { t.Errorf(\u0026#34;%s\\nTranslate(%q, %q, %q) = %q, want %q\u0026#34;, d.desc, d.srcLang, d.dstLang, d.srcText, got, d.wantDstText) } }) } } Here are a few examples of things to avoid:\n// Bad: // Too wordy. t.Run(\u0026#34;check that there is no mention of scratched records or hovercrafts\u0026#34;, ...) // Slashes cause problems on the command line. t.Run(\u0026#34;AM/PM confusion\u0026#34;, ...) Table-driven tests # Use table-driven tests when many different test cases can be tested using similar testing logic.\nWhen testing whether the actual output of a function is equal to the expected output. For example, the many tests of fmt.Sprintf or the minimal snippet below. When testing whether the outputs of a function always conform to the same set of invariants. For example, tests for net.Dial. Here is the minimal structure of a table-driven test, copied from the standard strings library. If needed, you may use different names, move the test slice into the test function, or add extra facilities such as subtests or setup and cleanup functions. Always keep useful test failures in mind.\n// Good: var compareTests = []struct { a, b string i int }{ {\u0026#34;\u0026#34;, \u0026#34;\u0026#34;, 0}, {\u0026#34;a\u0026#34;, \u0026#34;\u0026#34;, 1}, {\u0026#34;\u0026#34;, \u0026#34;a\u0026#34;, -1}, {\u0026#34;abc\u0026#34;, \u0026#34;abc\u0026#34;, 0}, {\u0026#34;ab\u0026#34;, \u0026#34;abc\u0026#34;, -1}, {\u0026#34;abc\u0026#34;, \u0026#34;ab\u0026#34;, 1}, {\u0026#34;x\u0026#34;, \u0026#34;ab\u0026#34;, 1}, {\u0026#34;ab\u0026#34;, \u0026#34;x\u0026#34;, -1}, {\u0026#34;x\u0026#34;, \u0026#34;a\u0026#34;, 1}, {\u0026#34;b\u0026#34;, \u0026#34;x\u0026#34;, -1}, // test runtime·memeq\u0026#39;s chunked implementation {\u0026#34;abcdefgh\u0026#34;, \u0026#34;abcdefgh\u0026#34;, 0}, {\u0026#34;abcdefghi\u0026#34;, \u0026#34;abcdefghi\u0026#34;, 0}, {\u0026#34;abcdefghi\u0026#34;, \u0026#34;abcdefghj\u0026#34;, -1}, } func TestCompare(t *testing.T) { for _, tt := range compareTests { cmp := Compare(tt.a, tt.b) if cmp != tt.i { t.Errorf(`Compare(%q, %q) = %v`, tt.a, tt.b, cmp) } } } Note: The failure messages in this example above fulfill the guidance to identify the function and identify the input. There’s no need to identify the row numerically.\nWhen some test cases need to be checked using different logic from other test cases, it is more appropriate to write multiple test functions, as explained in GoTip #50: Disjoint Table Tests. The logic of your test code can get difficult to understand when each entry in a table has its own different conditional logic to check each output for its inputs. If test cases have different logic but identical setup, a sequence of subtests within a single test function might make sense.\nYou can combine table-driven tests with multiple test functions. For example, when testing that a function’s output exactly matches the expected output and that the function returns a non-nil error for an invalid input, then writing two separate table-driven test functions is the best approach: one for normal non-error outputs, and one for error outputs.\nData-driven test cases # Table test rows can sometimes become complicated, with the row values dictating conditional behavior inside the test case. The extra clarity from the duplication between the test cases is necessary for readability.\n// Good: type decodeCase struct { name string input string output string err error } func TestDecode(t *testing.T) { // setupCodex is slow as it creates a real Codex for the test. codex := setupCodex(t) var tests []decodeCase // rows omitted for brevity for _, test := range tests { t.Run(test.name, func(t *testing.T) { output, err := Decode(test.input, codex) if got, want := output, test.output; got != want { t.Errorf(\u0026#34;Decode(%q) = %v, want %v\u0026#34;, test.input, got, want) } if got, want := err, test.err; !cmp.Equal(got, want) { t.Errorf(\u0026#34;Decode(%q) err %q, want %q\u0026#34;, test.input, got, want) } }) } } func TestDecodeWithFake(t *testing.T) { // A fakeCodex is a fast approximation of a real Codex. codex := newFakeCodex() var tests []decodeCase // rows omitted for brevity for _, test := range tests { t.Run(test.name, func(t *testing.T) { output, err := Decode(test.input, codex) if got, want := output, test.output; got != want { t.Errorf(\u0026#34;Decode(%q) = %v, want %v\u0026#34;, test.input, got, want) } if got, want := err, test.err; !cmp.Equal(got, want) { t.Errorf(\u0026#34;Decode(%q) err %q, want %q\u0026#34;, test.input, got, want) } }) } } In the counterexample below, note how hard it is to distinguish between which type of Codex is used per test case in the case setup. (The highlighted parts run afoul of the advice from TotT: Data Driven Traps! .)\n// Bad: type decodeCase struct { name string input string codex testCodex output string err error } type testCodex int const ( fake testCodex = iota prod ) func TestDecode(t *testing.T) { var tests []decodeCase // rows omitted for brevity for _, test := tests { t.Run(test.name, func(t *testing.T) { var codex Codex switch test.codex { case fake: codex = newFakeCodex() case prod: codex = setupCodex(t) default: t.Fatalf(\u0026#34;unknown codex type: %v\u0026#34;, codex) } output, err := Decode(test.input, codex) if got, want := output, test.output; got != want { t.Errorf(\u0026#34;Decode(%q) = %q, want %q\u0026#34;, test.input, got, want) } if got, want := err, test.err; !cmp.Equal(got, want) { t.Errorf(\u0026#34;Decode(%q) err %q, want %q\u0026#34;, test.input, got, want) } }) } } Identifying the row # Do not use the index of the test in the test table as a substitute for naming your tests or printing the inputs. Nobody wants to go through your test table and count the entries in order to figure out which test case is failing.\n// Bad: tests := []struct { input, want string }{ {\u0026#34;hello\u0026#34;, \u0026#34;HELLO\u0026#34;}, {\u0026#34;wORld\u0026#34;, \u0026#34;WORLD\u0026#34;}, } for i, d := range tests { if strings.ToUpper(d.input) != d.want { t.Errorf(\u0026#34;failed on case #%d\u0026#34;, i) } } Add a test description to your test struct and print it along failure messages. When using subtests, your subtest name should be effective in identifying the row.\nImportant: Even though t.Run scopes the output and execution, you must always identify the input. The table test row names must follow the subtest naming guidance.\nTest helpers # A test helper is a function that performs a setup or cleanup task. All failures that occur in test helpers are expected to be failures of the environment (not from the code under test) — for example when a test database cannot be started because there are no more free ports on this machine.\nIf you pass a *testing.T, call t.Helper to attribute failures in the test helper to the line where the helper is called. This parameter should come after a context parameter, if present, and before any remaining parameters.\n// Good: func TestSomeFunction(t *testing.T) { golden := readFile(t, \u0026#34;testdata/golden-result.txt\u0026#34;) // ... tests against golden ... } // readFile returns the contents of a data file. // It must only be called from the same goroutine as started the test. func readFile(t *testing.T, filename string) string { t.Helper() contents, err := runfiles.ReadFile(filename) if err != nil { t.Fatal(err) } return string(contents) } Do not use this pattern when it obscures the connection between a test failure and the conditions that led to it. Specifically, the guidance about assert libraries still applies, and t.Helper should not be used to implement such libraries.\nTip: For more on the distinction between test helpers and assertion helpers, see best practices.\nAlthough the above refers to *testing.T, much of the advice stays the same for benchmark and fuzz helpers.\nTest package # Tests in the same package # Tests may be defined in the same package as the code being tested.\nTo write a test in the same package:\nPlace the tests in a foo_test.go file Use package foo for the test file Do not explicitly import the package to be tested # Good: go_library( name = \u0026#34;foo\u0026#34;, srcs = [\u0026#34;foo.go\u0026#34;], deps = [ ... ], ) go_test( name = \u0026#34;foo_test\u0026#34;, size = \u0026#34;small\u0026#34;, srcs = [\u0026#34;foo_test.go\u0026#34;], library = \u0026#34;:foo\u0026#34;, deps = [ ... ], ) A test in the same package can access unexported identifiers in the package. This may enable better test coverage and more concise tests. Be aware that any examples declared in the test will not have the package names that a user will need in their code.\nTests in a different package # It is not always appropriate or even possible to define a test in the same package as the code being tested. In these cases, use a package name with the _test suffix. This is an exception to the “no underscores” rule to package names. For example:\nIf an integration test does not have an obvious library that it belongs to\n// Good: package gmailintegration_test import \u0026#34;testing\u0026#34; If defining the tests in the same package results in circular dependencies\n// Good: package fireworks_test import ( \u0026#34;fireworks\u0026#34; \u0026#34;fireworkstestutil\u0026#34; // fireworkstestutil also imports fireworks ) Use package testing # The Go standard library provides the testing package. This is the only testing framework permitted for Go code in the Google codebase. In particular, assertion libraries and third-party testing frameworks are not allowed.\nThe testing package provides a minimal but complete set of functionality for writing good tests:\nTop-level tests Benchmarks Runnable examples Subtests Logging Failures and fatal failures These are designed to work cohesively with core language features like composite literal and if-with-initializer syntax to enable test authors to write [clear, readable, and maintainable tests].\nNon-decisions # A style guide cannot enumerate positive prescriptions for all matters, nor can it enumerate all matters about which it does not offer an opinion. That said, here are a few things where the readability community has previously debated and has not achieved consensus about.\nLocal variable initialization with zero value. var i int and i := 0 are equivalent. See also initialization best practices. Empty composite literal vs. new or make. \u0026amp;File{} and new(File) are equivalent. So are map[string]bool{} and make(map[string]bool). See also composite declaration best practices. got, want argument ordering in cmp.Diff calls. Be locally consistent, and include a legend in your failure message. errors.New vs fmt.Errorf on non-formatted strings. errors.New(\u0026quot;foo\u0026quot;) and fmt.Errorf(\u0026quot;foo\u0026quot;) may be used interchangeably. If there are special circumstances where they come up again, the readability mentor might make an optional comment, but in general the author is free to pick the style they prefer in the given situation.\nNaturally, if anything not covered by the style guide does need more discussion, authors are welcome to ask – either in the specific review, or on internal message boards.\n"}]