<!doctype html><html lang=zh dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Go 风格决策 # https://google.github.io/styleguide/go/decisions
概述 | 指南 | 决策 | 最佳实践
**注意：**本文是 Google Go 风格 系列文档的一部分。本文档是 规范性(normative) 但不是强制规范(canonical)，并且从属于Google 风格指南。请参阅概述获取更多详细信息。
关于 # 本文包含旨在统一和为 Go 可读性导师给出的建议提供标准指导、解释和示例的风格决策。
本文档并不详尽，且会随着时间的推移而增加。如果风格指南 与此处给出的建议相矛盾，风格指南优先，并且本文档应相应更新。
参见 关于 获取 Go 风格的全套文档。
以下部分已从样式决策移至指南的一部分：
混合大写字母MixedCaps: 参见 https://google.github.io/styleguide/go/guide#mixed-caps 格式化Formatting: 参见 https://google.github.io/styleguide/go/guide#formatting 行长度Line Length: 参见 https://google.github.io/styleguide/go/guide#line-length 命名Naming # 有关命名的总体指导，请参阅核心风格指南 中的命名部分，以下部分对命名中的特定区域提供进一步的说明。
下划线Underscores # Go 中的命名通常不应包含下划线。 这个原则有三个例外：
仅由生成代码导入的包名称可能包含下划线。有关如何选择多词包名称的更多详细信息，请参阅包名称。 *_test.go 文件中的测试、基准和示例函数名称可能包含下划线。 与操作系统或 cgo 互操作的低级库可能会重用标识符，如 syscall 中所做的那样。在大多数代码库中，这预计是非常罕见的。 包名称Package names # Go 包名称应该简短并且只包含小写字母。由多个单词组成的包名称应全部小写。例如，包 tabwriter 不应该命名为 tabWriter、TabWriter 或 tab_writer。"><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content><meta property="og:description" content="Go 风格决策 # https://google.github.io/styleguide/go/decisions
概述 | 指南 | 决策 | 最佳实践
**注意：**本文是 Google Go 风格 系列文档的一部分。本文档是 规范性(normative) 但不是强制规范(canonical)，并且从属于Google 风格指南。请参阅概述获取更多详细信息。
关于 # 本文包含旨在统一和为 Go 可读性导师给出的建议提供标准指导、解释和示例的风格决策。
本文档并不详尽，且会随着时间的推移而增加。如果风格指南 与此处给出的建议相矛盾，风格指南优先，并且本文档应相应更新。
参见 关于 获取 Go 风格的全套文档。
以下部分已从样式决策移至指南的一部分：
混合大写字母MixedCaps: 参见 https://google.github.io/styleguide/go/guide#mixed-caps 格式化Formatting: 参见 https://google.github.io/styleguide/go/guide#formatting 行长度Line Length: 参见 https://google.github.io/styleguide/go/guide#line-length 命名Naming # 有关命名的总体指导，请参阅核心风格指南 中的命名部分，以下部分对命名中的特定区域提供进一步的说明。
下划线Underscores # Go 中的命名通常不应包含下划线。 这个原则有三个例外：
仅由生成代码导入的包名称可能包含下划线。有关如何选择多词包名称的更多详细信息，请参阅包名称。 *_test.go 文件中的测试、基准和示例函数名称可能包含下划线。 与操作系统或 cgo 互操作的低级库可能会重用标识符，如 syscall 中所做的那样。在大多数代码库中，这预计是非常罕见的。 包名称Package names # Go 包名称应该简短并且只包含小写字母。由多个单词组成的包名称应全部小写。例如，包 tabwriter 不应该命名为 tabWriter、TabWriter 或 tab_writer。"><meta property="og:type" content="article"><meta property="og:url" content="https://gocn.github.io/styleguide/docs/03-decisions/"><meta property="article:section" content="docs"><title>03 Decisions | Google Style Guides</title><link rel=manifest href=/styleguide/manifest.json><link rel=icon href=/styleguide/favicon.png type=image/x-icon><link rel=stylesheet href=/styleguide/book.min.c58292d36b18b675680ab9baea2029204537b839ea72f258746ec0f32ce8d6c8.css integrity="sha256-xYKS02sYtnVoCrm66iApIEU3uDnqcvJYdG7A8yzo1sg=" crossorigin=anonymous><script defer src=/styleguide/flexsearch.min.js></script>
<script defer src=/styleguide/zh.search.min.6b3912d11a0152f047ed335b996dc63110b8ecf715dd0cb54bf7e4c28dfb704c.js integrity="sha256-azkS0RoBUvBH7TNbmW3GMRC47PcV3Qy1S/fkwo37cEw=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/styleguide/><span>Google Style Guides</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><p><strong>开始学习</strong></p><ul><li><a href=/styleguide/docs/01-overview/>1. 概览</a></li><li><a href=/styleguide/docs/02-guide/>2. Go 编程规范</a></li></ul></li><li><p><a href=https://github.com/gocn/styleguide><strong>Fork on Github</strong></a></p></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/styleguide/svg/menu.svg class=book-icon alt=Menu></label>
<strong>03 Decisions</strong>
<label for=toc-control><img src=/styleguide/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#关于>关于</a></li><li><a href=#命名naming>命名Naming</a><ul><li><a href=#下划线underscores>下划线Underscores</a></li><li><a href=#包名称package-names>包名称Package names</a></li><li><a href=#接收者命名receiver-names>接收者命名Receiver names</a></li><li><a href=#常量命名constant-names>常量命名Constant names</a></li><li><a href=#缩写词initialisms>缩写词Initialisms</a></li><li><a href=#get方法getters>Get方法Getters</a></li><li><a href=#变量名variable-names>变量名Variable names</a></li><li><a href=#重复repetition>重复Repetition</a></li></ul></li><li><a href=#评论commentary>评论Commentary</a><ul><li><a href=#注释行长度comment-line-length>注释行长度Comment line length</a></li><li><a href=#文档注释doc-comments>文档注释Doc comments</a></li><li><a href=#注释语句comment-sentences>注释语句Comment sentences</a></li><li><a href=#示例examples>示例Examples</a></li><li><a href=#命名的结果参数named-result-parameters>命名的结果参数Named result parameters</a></li><li><a href=#包注释>包注释</a></li></ul></li><li><a href=#导入>导入</a><ul><li><a href=#导入重命名>导入重命名</a></li><li><a href=#导入分组>导入分组</a></li><li><a href=#导入空-import-_>导入"空" (<code>import _</code>)</a></li><li><a href=#导入--import->导入 “.” (<code>import .</code>)</a></li></ul></li><li><a href=#错误>错误</a><ul><li><a href=#返回错误>返回错误</a></li><li><a href=#错误字符串>错误字符串</a></li><li><a href=#错误处理>错误处理</a></li><li><a href=#in-band-错误>In-band 错误</a></li><li><a href=#缩进错误流程>缩进错误流程</a></li></ul></li><li><a href=#语言>语言</a><ul><li><a href=#字面格式化>字面格式化</a></li><li><a href=#nil-切片>Nil 切片</a></li><li><a href=#缩进的混乱>缩进的混乱</a></li><li><a href=#函数格式化>函数格式化</a></li><li><a href=#条件和循环>条件和循环</a></li><li><a href=#复制>复制</a></li><li><a href=#不要-panic>不要 panic</a></li><li><a href=#must类函数>Must类函数</a></li><li><a href=#goroutine-生命周期>Goroutine 生命周期</a></li><li><a href=#接口>接口</a></li><li><a href=#泛型>泛型</a></li><li><a href=#参数值传递>参数值传递</a></li><li><a href=#接收者类型>接收者类型</a></li><li><a href=#switch-和-break><code>switch</code> 和 <code>break</code></a></li><li><a href=#同步函数>同步函数</a></li><li><a href=#类型别名>类型别名</a></li><li><a href=#使用-q>使用 %q</a></li><li><a href=#使用-any>使用 any</a></li></ul></li><li><a href=#通用库>通用库</a><ul><li><a href=#flags>Flags</a></li><li><a href=#日志>日志</a></li><li><a href=#上下文>上下文</a></li><li><a href=#cryptorand>crypto/rand</a></li></ul></li><li><a href=#有用的测试失败>有用的测试失败</a><ul><li><a href=#断言库>断言库</a></li><li><a href=#标识出方法>标识出方法</a></li><li><a href=#标识出输入>标识出输入</a></li><li><a href=#got-before-want>Got before want</a></li><li><a href=#全结构比较>全结构比较</a></li><li><a href=#compare-stable-results>Compare stable results</a></li><li><a href=#keep-going>Keep going</a></li><li><a href=#equality-comparison-and-diffs>Equality comparison and diffs</a></li><li><a href=#level-of-detail>Level of detail</a></li><li><a href=#print-diffs>Print diffs</a></li><li><a href=#test-error-semantics>Test error semantics</a></li></ul></li><li><a href=#test-structure>Test structure</a><ul><li><a href=#subtests>Subtests</a></li><li><a href=#table-driven-tests>Table-driven tests</a></li><li><a href=#test-helpers>Test helpers</a></li><li><a href=#test-package>Test package</a></li><li><a href=#use-package-testing>Use package <code>testing</code></a></li></ul></li><li><a href=#non-decisions>Non-decisions</a></li></ul></nav></aside></header><article class=markdown><h1 id=go-风格决策>Go 风格决策
<a class=anchor href=#go-%e9%a3%8e%e6%a0%bc%e5%86%b3%e7%ad%96>#</a></h1><p><a href=https://google.github.io/styleguide/go/decisions>https://google.github.io/styleguide/go/decisions</a></p><p><a href=https://google.github.io/styleguide/go/index>概述</a> | <a href=https://google.github.io/styleguide/go/guide>指南</a> | <a href=https://google.github.io/styleguide/go/decisions>决策</a> | <a href=https://google.github.io/styleguide/go/best-practices>最佳实践</a></p><p>**注意：**本文是 Google <a href=https://google.github.io/styleguide/go/index>Go 风格</a> 系列文档的一部分。本文档是 <strong><a href=https://google.github.io/styleguide/go/index#normative>规范性(normative)</a> 但不是<a href=https://google.github.io/styleguide/go/index#canonical>强制规范(canonical)</a></strong>，并且从属于<a href=https://google.github.io/styleguide/go/guide>Google 风格指南</a>。请参阅<a href=https://google.github.io/styleguide/go/index#about>概述</a>获取更多详细信息。</p><h2 id=关于>关于
<a class=anchor href=#%e5%85%b3%e4%ba%8e>#</a></h2><p>本文包含旨在统一和为 Go 可读性导师给出的建议提供标准指导、解释和示例的风格决策。</p><p>本文档<strong>并不详尽</strong>，且会随着时间的推移而增加。如果<a href=https://google.github.io/styleguide/go/guide>风格指南</a> 与此处给出的建议相矛盾，<strong>风格指南优先</strong>，并且本文档应相应更新。</p><p>参见 <a href=https://google.github.io/styleguide/go#about>关于</a> 获取 Go 风格的全套文档。</p><p>以下部分已从样式决策移至指南的一部分：</p><ul><li><strong>混合大写字母MixedCaps</strong>: 参见 <a href=https://google.github.io/styleguide/go/guide#mixed-caps>https://google.github.io/styleguide/go/guide#mixed-caps</a></li><li><strong>格式化Formatting</strong>: 参见 <a href=https://google.github.io/styleguide/go/guide#formatting>https://google.github.io/styleguide/go/guide#formatting</a></li><li><strong>行长度Line Length</strong>: 参见 <a href=https://google.github.io/styleguide/go/guide#line-length>https://google.github.io/styleguide/go/guide#line-length</a></li></ul><h2 id=命名naming>命名Naming
<a class=anchor href=#%e5%91%bd%e5%90%8dnaming>#</a></h2><p>有关命名的总体指导，请参阅<a href=https://google.github.io/styleguide/go/guide#naming>核心风格指南</a> 中的命名部分，以下部分对命名中的特定区域提供进一步的说明。</p><h3 id=下划线underscores>下划线Underscores
<a class=anchor href=#%e4%b8%8b%e5%88%92%e7%ba%bfunderscores>#</a></h3><p>Go 中的命名通常不应包含下划线。 这个原则有三个例外：</p><ol><li>仅由生成代码导入的包名称可能包含下划线。有关如何选择多词包名称的更多详细信息，请参阅<a href=https://google.github.io/styleguide/go/decisions#package-names>包名称</a>。</li><li><code>*_test.go</code> 文件中的测试、基准和示例函数名称可能包含下划线。</li><li>与操作系统或 cgo 互操作的低级库可能会重用标识符，如 <a href=https://pkg.go.dev/syscall#pkg-constants><code>syscall</code></a> 中所做的那样。在大多数代码库中，这预计是非常罕见的。</li></ol><h3 id=包名称package-names>包名称Package names
<a class=anchor href=#%e5%8c%85%e5%90%8d%e7%a7%b0package-names>#</a></h3><p>Go 包名称应该简短并且只包含小写字母。由多个单词组成的包名称应全部小写。例如，包 <a href=https://pkg.go.dev/text/tabwriter><code>tabwriter</code></a> 不应该命名为 <code>tabWriter</code>、<code>TabWriter</code> 或 <code>tab_writer</code>。</p><p>避免选择可能被常用局部变量<a href=https://google.github.io/styleguide/go/best-practices#shadowing>遮蔽覆盖</a> 的包名称。例如，<code>usercount</code> 是比 <code>count</code> 更好的包名，因为 <code>count</code> 是常用变量名。</p><p>Go 包名称不应该有下划线。如果您需要导入名称中确实有一个包（通常来自生成的或第三方代码），则必须在导入时将其重命名为适合在 Go 代码中使用的名称。</p><p>一个例外是仅由生成的代码导入的包名称可能包含下划线。具体例子包括：</p><ul><li>对外部测试包使用 _test 后缀，例如集成测试</li><li>使用 <code>_test</code> 后缀作为 <a href=https://go.dev/blog/examples>包级文档示例</a></li></ul><p>避免使用无意义的包名称，例如 <code>util</code>、<code>utility</code>、<code>common</code>、<code>helper</code> 等。查看更多关于<a href=https://google.github.io/styleguide/go/best-practices#util-packages>所谓的“实用程序包”</a>。</p><p>当导入的包被重命名时（例如 <code>import foob "path/to/foo_go_proto"</code>），包的本地名称必须符合上述规则，因为本地名称决定了包中的符号在文件中的引用方式.如果给定的导入在多个文件中重命名，特别是在相同或附近的包中，则应尽可能使用相同的本地名称以保持一致性。</p><p>另请参阅：https://go.dev/blog/package-names</p><h3 id=接收者命名receiver-names>接收者命名Receiver names
<a class=anchor href=#%e6%8e%a5%e6%94%b6%e8%80%85%e5%91%bd%e5%90%8dreceiver-names>#</a></h3><p><a href=https://golang.org/ref/spec#Method_declarations>接收者</a> 变量名必须满足:</p><ul><li>短（通常是一两个字母的长度）</li><li>类型本身的缩写</li><li>始终如一地应用于该类型的每个接收者</li></ul><table><thead><tr><th>长名称</th><th>更好命名</th></tr></thead><tbody><tr><td><code>func (tray Tray)</code></td><td><code>func (t Tray)</code></td></tr><tr><td><code>func (info *ResearchInfo)</code></td><td><code>func (ri *ResearchInfo)</code></td></tr><tr><td><code>func (this *ReportWriter)</code></td><td><code>func (w *ReportWriter)</code></td></tr><tr><td><code>func (self *Scanner)</code></td><td><code>func (s *Scanner)</code></td></tr></tbody></table><h3 id=常量命名constant-names>常量命名Constant names
<a class=anchor href=#%e5%b8%b8%e9%87%8f%e5%91%bd%e5%90%8dconstant-names>#</a></h3><p>常量名称必须像 Go 中的所有其他名称一样使用 <a href=https://google.github.io/styleguide/go/guide#mixed-caps>混合大写字母MixedCaps</a>。 （<a href=https://tour.golang.org/basics/3>导出</a> 常量以大写字母开头，而未导出的常量以小写字母开头。）即使打破了其他语言的约定，这也是适用的。常量名称不应是其值的派生词，而应该解释值所表示的含义。</p><pre tabindex=0><code>// Good:
const MaxPacketSize = 512

const (
    ExecuteBit = 1 &lt;&lt; iota
    WriteBit
    ReadBit
)
</code></pre><p>不要使用非混合大写常量名称或带有 <code>K</code> 前缀的常量。</p><pre tabindex=0><code>// Bad:
const MAX_PACKET_SIZE = 512
const kMaxBufferSize = 1024
const KMaxUsersPergroup = 500
</code></pre><p>根据它们的角色而不是它们的值来命名常量。 如果一个常量除了它的值之外没有其他作用，那么就没有必要将它定义为一个常量。</p><pre tabindex=0><code>// Bad:
const Twelve = 12

const (
    UserNameColumn = &#34;username&#34;
    GroupColumn    = &#34;group&#34;
)
</code></pre><h3 id=缩写词initialisms>缩写词Initialisms
<a class=anchor href=#%e7%bc%a9%e5%86%99%e8%af%8dinitialisms>#</a></h3><p>名称中的首字母缩略词或单独的首字母缩略词（例如，“URL”和“NATO”）应该具有相同的大小写。 <code>URL</code> 应显示为 <code>URL</code> 或 <code>url</code>（如 <code>urlPony</code> 或 <code>URLPony</code>），绝不能显示为 <code>Url</code>。 这也适用于 <code>ID</code> 是“identifier”的缩写； 写 <code>appID</code> 而不是 <code>appId</code>。</p><ul><li>在具有多个首字母缩写的名称中（例如 <code>XMLAPI</code> 因为它包含 <code>XML</code> 和 <code>API</code>），给定首字母缩写中的每个字母都应该具有相同的大小写，但名称中的每个首字母缩写不需要具有相同的大小写。</li><li>在带有包含小写字母的首字母缩写的名称中（例如<code>DDoS</code>、<code>iOS</code>、<code>gRPC</code>），首字母缩写应该像在标准中一样出现，除非您需要为了满足 <a href=https://golang.org/ref/spec#Exported_identifiers>导出</a> 而更改第一个字母。在这些情况下，整个缩写词应该是相同的情况（例如 <code>ddos</code>、<code>IOS</code>、<code>GRPC</code>）。</li></ul><table><thead><tr><th>缩写词</th><th>范围</th><th>正确</th><th>错误</th></tr></thead><tbody><tr><td>XML API</td><td>Exported</td><td><code>XMLAPI</code></td><td><code>XmlApi</code>, <code>XMLApi</code>, <code>XmlAPI</code>, <code>XMLapi</code></td></tr><tr><td>XML API</td><td>Unexported</td><td><code>xmlAPI</code></td><td><code>xmlapi</code>, <code>xmlApi</code></td></tr><tr><td>iOS</td><td>Exported</td><td><code>IOS</code></td><td><code>Ios</code>, <code>IoS</code></td></tr><tr><td>iOS</td><td>Unexported</td><td><code>iOS</code></td><td><code>ios</code></td></tr><tr><td>gRPC</td><td>Exported</td><td><code>GRPC</code></td><td><code>Grpc</code></td></tr><tr><td>gRPC</td><td>Unexported</td><td><code>gRPC</code></td><td><code>grpc</code></td></tr><tr><td>DDoS</td><td>Exported</td><td><code>DDoS</code></td><td><code>DDOS</code>, <code>Ddos</code></td></tr><tr><td>DDoS</td><td>Unexported</td><td><code>ddos</code></td><td><code>dDoS</code>, <code>dDOS</code></td></tr></tbody></table><h3 id=get方法getters>Get方法Getters
<a class=anchor href=#get%e6%96%b9%e6%b3%95getters>#</a></h3><p>函数和方法名称不应使用 <code>Get</code> 或 <code>get</code> 前缀，除非底层概念使用单词“get”（例如 HTTP GET）。此时，更应该直接以名词开头的名称，例如使用 <code>Counts</code> 而不是 <code>GetCounts</code>。</p><p>如果该函数涉及执行复杂的计算或执行远程调用，则可以使用<code>Compute</code> 或 <code>Fetch</code>等不同的词代替<code>Get</code>，以使读者清楚函数调用可能需要时间，并有可能会阻塞或失败。</p><h3 id=变量名variable-names>变量名Variable names
<a class=anchor href=#%e5%8f%98%e9%87%8f%e5%90%8dvariable-names>#</a></h3><p>一般的经验法则是，名称的长度应与其范围的大小成正比，并与其在该范围内使用的次数成反比。在文件范围内创建的变量可能需要多个单词，而单个内部块作用域内的变量可能是单个单词甚至只是一两个字符，以保持代码清晰并避免无关信息。</p><p>这是一条粗略的基础原则。这些数字准则不是严格的规则。要根据上下文、<a href=https://google.github.io/styleguide/go/guide#clarity>清晰</a> 和[简洁](<a href=https://google.github.io/styleguide/go/guide#>https://google.github.io/styleguide/go/guide#</a>简洁）来进行判断。</p><ul><li>小范围是执行一两个小操作的范围，比如 1-7 行。</li><li>中等范围是一些小的或一个大的操作，比如 8-15 行。</li><li>大范围是一个或几个大操作，比如 15-25 行。</li><li>非常大的范围是指超过一页（例如，超过 25 行）的任何内容。</li></ul><p>在小范围内可能非常清楚的名称（例如，<code>c</code> 表示计数器）在较大范围内可能不够用，并且需要澄清以提醒进一步了解其在代码中的用途。一个作用域中有很多变量，或者表示相似值或概念的变量，那就可能需要比作用域建议的采用更长的变量名称。</p><p>概念的特殊性也有助于保持变量名称的简洁。例如，假设只有一个数据库在使用，像<code>db</code>这样的短变量名通常可能保留给非常小的范围，即使范围非常大，也可能保持完全清晰。在这种情况下，根据范围的大小，单个词<code>database</code>可能是可接受的，但不是必需的，因为<code>db</code>是该词的一种非常常见的缩写，几乎没有其他解释。</p><p>局部变量的名称应该反映它包含的内容以及它在当前上下文中的使用方式，而不是值的来源。例如，通常情况下最佳局部变量名称与结构或协议缓冲区字段名称不同。</p><p>一般来说：</p><ul><li><p>像 <code>count</code> 或 <code>options</code> 这样的单字名称是一个很好的起点。</p></li><li><p>可以添加其他词来消除相似名称的歧义，例如 <code>userCount</code> 和 <code>projectCount</code>。</p></li><li><p>不要简单地省略字母来节省打字时间。例如，<code>Sandbox</code> 优于 <code>Sbx</code>，特别是对于导出的名称。</p></li><li><p>大多数变量名可省略 <a href=https://google.github.io/styleguide/go/decisions#repetitive-with-type>类型和类似类型的词</a></p><ul><li>对于数字，<code>userCount</code> 是比 <code>numUsers</code> 或 <code>usersInt</code> 更好的名称。</li><li>对于切片，<code>users</code> 是一个比 <code>userSlice</code> 更好的名字。</li><li>如果范围内有两个版本的值，则包含类似类型的限定符是可以接受的，例如，您可能将输入存储在 <code>ageString</code> 中，并使用 <code>age</code> 作为解析值。</li></ul></li><li><p>省略<a href=https://google.github.io/styleguide/go/decisions#repetitive-in-context>上下文</a> 中清楚的单词。例如，在 UserCount 方法的实现中，名为 userCount 的局部变量可能是多余的； <code>count</code>、<code>users</code> 甚至 <code>c</code> 都具有可读性。</p></li></ul><h4 id=单字母变量名single-letter-variable-names>单字母变量名Single-letter variable names
<a class=anchor href=#%e5%8d%95%e5%ad%97%e6%af%8d%e5%8f%98%e9%87%8f%e5%90%8dsingle-letter-variable-names>#</a></h4><p>单字母变量名是可以减少<a href=https://google.github.io/styleguide/go/decisions#repetition>重复</a> 的有用工具，但也可能使代码变得不透明。将它们的使用限制在完整单词很明显以及它会重复出现以代替单字母变量的情况。</p><p>一般来说：</p><ul><li>对于<a href=https://google.github.io/styleguide/go/decisions#receiver-names>方法接收者变量</a>，最好使用一个字母或两个字母的名称。</li><li>对常见类型使用熟悉的变量名通常很有帮助：<ul><li><code>r</code> 用于 <code>io.Reader</code> 或 <code>*http.Request</code></li><li><code>w</code> 用于 <code>io.Writer</code> 或 <code>http.ResponseWriter</code></li></ul></li><li>单字母标识符作为整数循环变量是可接受的，特别是对于索引（例如，<code>i</code>）和坐标（例如，<code>x</code> 和 <code>y</code>）。</li><li>当范围很短时，循环标识符使用缩写是可接受的，例如<code>for _, n := range nodes { ... }</code>。</li></ul><h3 id=重复repetition>重复Repetition
<a class=anchor href=#%e9%87%8d%e5%a4%8drepetition>#</a></h3><p>一段 Go 源代码应该避免不必要的重复。 一个常见的情形是重复名称，其中通常包含不必要的单词或重复其上下文或类型。 如果相同或相似的代码段在很近的地方多次出现，代码本身也可能是不必要的重复。</p><p>重复命名可以有多种形式，包括：</p><h4 id=包名-vs-可导出符号名package-vs-exported-symbol-name>包名 vs 可导出符号名Package vs. exported symbol name
<a class=anchor href=#%e5%8c%85%e5%90%8d-vs-%e5%8f%af%e5%af%bc%e5%87%ba%e7%ac%a6%e5%8f%b7%e5%90%8dpackage-vs-exported-symbol-name>#</a></h4><p>当命名导出的符号时，包的名称始终在包外可见，因此应减少或消除两者之间的冗余信息。如果一个包如果需要仅导出一种类型并且以包本身命名，则构造函数的规范名称是<code>New</code>（如果需要的话）。</p><blockquote><p><strong>实例:</strong> 重复的名称 -> 更好的名称</p><ul><li><code>widget.NewWidget</code> -> <code>widget.New</code></li><li><code>widget.NewWidgetWithName</code> -> <code>widget.NewWithName</code></li><li><code>db.LoadFromDatabase</code> -> <code>db.Load</code></li><li><code>goatteleportutil.CountGoatsTeleported</code> -> <code>gtutil.CountGoatsTeleported</code> or <code>goatteleport.Count</code></li><li><code>myteampb.MyTeamMethodRequest</code> -> <code>mtpb.MyTeamMethodRequest</code> or <code>myteampb.MethodRequest</code></li></ul></blockquote><h4 id=变量名-vs-类型variable-name-vs-type>变量名 vs 类型Variable name vs. type
<a class=anchor href=#%e5%8f%98%e9%87%8f%e5%90%8d-vs-%e7%b1%bb%e5%9e%8bvariable-name-vs-type>#</a></h4><p>编译器总是知道变量的类型，并且在大多数情况下，阅读者也可以通过变量的使用方式清楚地知道变量是什么类型。只有当一个变量的值在同一范围内出现两次时，才有需要明确变量的类型。</p><table><thead><tr><th>重复的名称</th><th>更好的名称</th></tr></thead><tbody><tr><td><code>var numUsers int</code></td><td><code>var users int</code></td></tr><tr><td><code>var nameString string</code></td><td><code>var name string</code></td></tr><tr><td><code>var primaryProject *Project</code></td><td><code>var primary *Project</code></td></tr></tbody></table><p>如果该值以多种形式出现，这可以通过额外的词（如<code>raw</code>和<code>parsed</code>）或底层表示来澄清：</p><pre tabindex=0><code>// Good:
limitStr := r.FormValue(&#34;limit&#34;)
limit, err := strconv.Atoi(limitStr)
// Good:
limitRaw := r.FormValue(&#34;limit&#34;)
limit, err := strconv.Atoi(limitRaw)
</code></pre><h4 id=外部上下文-vs-本地名称external-context-vs-local-names>外部上下文 vs 本地名称External context vs. local names
<a class=anchor href=#%e5%a4%96%e9%83%a8%e4%b8%8a%e4%b8%8b%e6%96%87-vs-%e6%9c%ac%e5%9c%b0%e5%90%8d%e7%a7%b0external-context-vs-local-names>#</a></h4><p>包含来自周围上下文信息的名称通常会产生额外的噪音，而没有任何好处。 包名、方法名、类型名、函数名、导入路径，甚至文件名都可以提供自动限定其名称的上下文。
Names that include information from their surrounding context often create extra noise without benefit. The package name, method name, type name, function name, import path, and even filename can all provide context that automatically qualifies all names within.</p><pre tabindex=0><code>// Bad:
// In package &#34;ads/targeting/revenue/reporting&#34;
type AdsTargetingRevenueReport struct{}

func (p *Project) ProjectName() string
// Good:
// In package &#34;ads/targeting/revenue/reporting&#34;
type Report struct{}

func (p *Project) Name() string
// Bad:
// In package &#34;sqldb&#34;
type DBConnection struct{}
// Good:
// In package &#34;sqldb&#34;
type Connection struct{}
// Bad:
// In package &#34;ads/targeting&#34;
func Process(in *pb.FooProto) *Report {
    adsTargetingID := in.GetAdsTargetingID()
}
// Good:
// In package &#34;ads/targeting&#34;
func Process(in *pb.FooProto) *Report {
    id := in.GetAdsTargetingID()
}
</code></pre><p>重复通常应该在符号用户的上下文中进行评估，而不是孤立地进行评估。例如，下面的代码有很多名称，在某些情况下可能没问题，但在上下文中是多余的：</p><pre tabindex=0><code>// Bad:
func (db *DB) UserCount() (userCount int, err error) {
    var userCountInt64 int64
    if dbLoadError := db.LoadFromDatabase(&#34;count(distinct users)&#34;, &amp;userCountInt64); dbLoadError != nil {
        return 0, fmt.Errorf(&#34;failed to load user count: %s&#34;, dbLoadError)
    }
    userCount = int(userCountInt64)
    return userCount, nil
}
</code></pre><p>相反，在上下文和使用上信息是清楚的情况下，常常可以忽略：</p><pre tabindex=0><code>// Good:
func (db *DB) UserCount() (int, error) {
    var count int64
    if err := db.Load(&#34;count(distinct users)&#34;, &amp;count); err != nil {
        return 0, fmt.Errorf(&#34;failed to load user count: %s&#34;, err)
    }
    return int(count), nil
}
</code></pre><h2 id=评论commentary>评论Commentary
<a class=anchor href=#%e8%af%84%e8%ae%bacommentary>#</a></h2><p>关于评论的约定（包括评论什么、使用什么风格、如何提供可运行的示例等）旨在支持阅读公共 API 文档的体验。 有关详细信息，请参阅 <a href=http://golang.org/doc/effective_go.html#commentary>Effective Go</a>。</p><p>最佳实践文档关于 <a href=https://google.github.io/styleguide/go/best-practices#documentation-conventions>文档约定</a> 的部分进一步讨论了这一点。</p><p>**最佳实践：**在开发和代码审查期间使用<a href=https://google.github.io/styleguide/go/best-practices#documentation-preview>文档预览</a> 查看文档和可运行示例是否有用 并以您期望的方式呈现。</p><p><strong>提示：</strong> Godoc 使用很少的特殊格式； 列表和代码片段通常应该缩进以避免换行。 除缩进外，通常应避免装饰。</p><h3 id=注释行长度comment-line-length>注释行长度Comment line length
<a class=anchor href=#%e6%b3%a8%e9%87%8a%e8%a1%8c%e9%95%bf%e5%ba%a6comment-line-length>#</a></h3><p>确保即使在较窄的屏幕上注释的可读性。</p><p>当评论变得太长时，建议将其包装成多个单行评论。在可能的情况下，争取在 80 列宽的终端上阅读良好的注释，但这并不是硬性限制； Go 中的注释没有固定的行长度限制。例如，标准库经常选择根据标点符号来打断注释，这有时会使个别行更接近 60-70 个字符标记。</p><p>有很多现有代码的注释长度超过 80 个字符。本指南不应作为更改此类代码作为可读性审查的一部分的理由（请参阅<a href=https://google.github.io/styleguide/go/guide#consistency>一致性</a>），但鼓励团队作为其他重构的一部分，有机会时更新注释以遵循此指南。本指南的主要目标是确保所有 Go 可读性导师在提出建议时以及是否提出相同的建议。</p><p>有关评论的更多信息，请参阅此 <a href=https://blog.golang.org/godoc-documenting-go-code>来自 The Go Blog 的帖子</a>。</p><pre tabindex=0><code># Good:
// This is a comment paragraph.
// The length of individual lines doesn&#39;t matter in Godoc;
// but the choice of wrapping makes it easy to read on narrow screens.
//
// Don&#39;t worry too much about the long URL:
// https://supercalifragilisticexpialidocious.example.com:8080/Animalia/Chordata/Mammalia/Rodentia/Geomyoidea/Geomyidae/
//
// Similarly, if you have other information that is made awkward
// by too many line breaks, use your judgment and include a long line
// if it helps rather than hinders.
</code></pre><p>避免注释在小屏幕上重复换行，这是一种糟糕的阅读体验。</p><pre tabindex=0><code># Bad:
// This is a comment paragraph. The length of individual lines doesn&#39;t matter in
Godoc;
// but the choice of wrapping causes jagged lines on narrow screens or in
Critique,
// which can be annoying, especially when in a comment block that will wrap
repeatedly.
//
// Don&#39;t worry too much about the long URL:
// https://supercalifragilisticexpialidocious.example.com:8080/Animalia/Chordata/Mammalia/Rodentia/Geomyoidea/Geomyidae/
</code></pre><h3 id=文档注释doc-comments>文档注释Doc comments
<a class=anchor href=#%e6%96%87%e6%a1%a3%e6%b3%a8%e9%87%8adoc-comments>#</a></h3><p>所有顶级导出名称都必须有文档注释，具有不明显行为或含义的未导出类型或函数声明也应如此。 这些注释应该是<a href=https://google.github.io/styleguide/go/decisions#comment-sentences>完整句子</a>，以所描述对象的名称开头。 冠词（“a”、“an”、“the”）可以放在名字前面，使其读起来更自然。</p><pre tabindex=0><code>// Good:
// A Request represents a request to run a command.
type Request struct { ...

// Encode writes the JSON encoding of req to w.
func Encode(w io.Writer, req *Request) { ...
</code></pre><p>文档注释出现在 <a href=https://pkg.go.dev/>Godoc</a> 中，并通过 IDE 显示，因此应该为使用该包的任何人编写文档注释。</p><p>如果出现在结构中，文档注释适用于以下符号或字段组：</p><pre tabindex=0><code>// Good:
// Options configure the group management service.
type Options struct {
    // General setup:
    Name  string
    Group *FooGroup

    // Dependencies:
    DB *sql.DB

    // Customization:
    LargeGroupThreshold int // optional; default: 10
    MinimumMembers      int // optional; default: 2
}
</code></pre><p>**最佳实践：**如果你对未导出的代码有文档注释，请遵循与导出代码相同的习惯（即，以未导出的名称开始注释）。 这使得以后导出它变得容易，只需在注释和代码中用新导出的名称替换未导出的名称即可。</p><h3 id=注释语句comment-sentences>注释语句Comment sentences
<a class=anchor href=#%e6%b3%a8%e9%87%8a%e8%af%ad%e5%8f%a5comment-sentences>#</a></h3><p>完整的注释应该像标准英语句子一样包含大写和标点符号。 （作为一个例外，如果在其他方面很清楚，可以以非大写的标识符名称开始一个句子。这种情况最好只在段落的开头进行。）</p><p>作为句子片段的注释对标点符号或大小写没有此类要求。</p><p><a href=https://google.github.io/styleguide/go/decisions#doc-comments>文档注释</a> 应始终是完整的句子，因此应始终大写和标点符号。 简单的行尾注释（特别是对于结构字段）可以为假设字段名称是主语的简单短语。</p><pre tabindex=0><code>// Good:
// A Server handles serving quotes from the collected works of Shakespeare.
type Server struct {
    // BaseDir points to the base directory under which Shakespeare&#39;s works are stored.
    //
    // The directory structure is expected to be the following:
    //   {BaseDir}/manifest.json
    //   {BaseDir}/{name}/{name}-part{number}.txt
    BaseDir string

    WelcomeMessage  string // displayed when user logs in
    ProtocolVersion string // checked against incoming requests
    PageLength      int    // lines per page when printing (optional; default: 20)
}
</code></pre><h3 id=示例examples>示例Examples
<a class=anchor href=#%e7%a4%ba%e4%be%8bexamples>#</a></h3><p>包应该清楚地记录它们的预期用途。 尝试提供一个<a href=http://blog.golang.org/examples>可运行的例子</a>； 示例出现在 Godoc 中。 可运行示例属于测试文件，而不是生产源文件。 请参阅此示例（<a href=https://pkg.go.dev/time#example-Duration>Godoc</a>，[source](<a href=https://cs.opensource.google/go/go/+/HEAD:src/time>https://cs.opensource.google/go/go/+/HEAD:src/time</a> /example_test.go））。</p><p>如果无法提供可运行的示例，可以在代码注释中提供示例代码。 与注释中的其他代码和命令行片段一样，它应该遵循标准格式约定。</p><h3 id=命名的结果参数named-result-parameters>命名的结果参数Named result parameters
<a class=anchor href=#%e5%91%bd%e5%90%8d%e7%9a%84%e7%bb%93%e6%9e%9c%e5%8f%82%e6%95%b0named-result-parameters>#</a></h3><p>当有命名参数时，请考虑函数签名在 Godoc 中的显示方式。 函数本身的名称和结果参数的类型通常要足够清楚。</p><pre tabindex=0><code>// Good:
func (n *Node) Parent1() *Node
func (n *Node) Parent2() (*Node, error)
</code></pre><p>如果一个函数返回两个或多个相同类型的参数，添加名称会很有用。</p><pre tabindex=0><code>// Good:
func (n *Node) Children() (left, right *Node, err error)
</code></pre><p>如果调用者必须对特定的结果参数采取行动，命名它们可以帮助暗示行动是什么：</p><pre tabindex=0><code>// Good:
// WithTimeout returns a context that will be canceled no later than d duration
// from now.
//
// The caller must arrange for the returned cancel function to be called when
// the context is no longer needed to prevent a resource leak.
func WithTimeout(parent Context, d time.Duration) (ctx Context, cancel func())
</code></pre><p>在上面的代码中，取消是调用者必须执行的特定操作。但是，如果将结果参数单独写为<code>(Context, func())</code>，“取消函数”的含义就不清楚了。</p><p>当名称产生 <a href=https://google.github.io/styleguide/go/decisions#repetitive-with-type>不必要的重复</a> 时，不要使用命名结果参数。</p><pre tabindex=0><code>// Bad:
func (n *Node) Parent1() (node *Node)
func (n *Node) Parent2() (node *Node, err error)
</code></pre><p>不要为了避免在函数内声明变量而使用命名结果参数。这种做法会导致不必要的冗长API，但收益只是微小的简洁性。</p><p><a href=https://tour.golang.org/basics/7>裸返回</a> 仅在小函数中是可接受的。 一旦它是一个中等大小的函数，就需要明确你的返回值。 同样，不要仅仅因为可以裸返回就使用命名结果参数。 <a href=https://google.github.io/styleguide/go/guide#clarity>清晰度</a> 总是比在你的函数中节省几行更重要。</p><p>如果必须在延迟闭包中更改结果参数的值，则命名结果参数始终是可以接受的。</p><blockquote><p><strong>提示：</strong> 类型通常比函数签名中的名称更清晰。 <a href=https://google.github.io/styleguide/go/index.html#gotip>GoTip #38：作为命名类型的函数</a> 演示了这一点。</p><p>在上面的 <a href=https://pkg.go.dev/context#WithTimeout><code>WithTimeout</code></a> 中，代码使用了一个 <a href=https://pkg.go.dev/context#CancelFunc><code>CancelFunc</code></a> 而不是结果参数列表中的原始<code>func()</code>，并且几乎不需要做任何记录工作。</p></blockquote><h3 id=包注释>包注释
<a class=anchor href=#%e5%8c%85%e6%b3%a8%e9%87%8a>#</a></h3><p>包注释必须出现在包内语句的上方，注释和包名称之间没有空行。 例子：</p><pre tabindex=0><code>// Good:
// Package math provides basic constants and mathematical functions.
//
// This package does not guarantee bit-identical results across architectures.
package math
</code></pre><p>每个包必须有一个包注释。 如果一个包由多个文件组成，那么其中一个文件应该有包注释。</p><p><code>main</code> 包的注释形式略有不同，其中 BUILD 文件中的 <code>go_binary</code> 规则的名称代替了包名。</p><pre tabindex=0><code>// Good:
// The seed_generator command is a utility that generates a Finch seed file
// from a set of JSON study configs.
package main
</code></pre><p>只要二进制文件的名称与 BUILD 文件中所写的完全一致，其他风格的注释也是可以了。 当二进制名称是第一个单词时，即使它与命令行调用的拼写不严格匹配，也需要将其大写。</p><pre tabindex=0><code>// Good:
// Binary seed_generator ...
// Command seed_generator ...
// Program seed_generator ...
// The seed_generator command ...
// The seed_generator program ...
// Seed_generator ...
</code></pre><p>提示:</p><ul><li><p>命令行调用示例和 API 用法可以是有用的文档。 对于 Godoc 格式，缩进包含代码的注释行。</p></li><li><p>如果没有明显的main文件或者包注释特别长，可以将文档注释放在名为 doc.go 的文件中，只有注释和包子句。</p></li><li><p>可以使用多行注释代替多个单行注释。 如果文档包含可能对从源文件复制和粘贴有用的部分，如示例命令行（用于二进制文件）和模板示例，这将非常有用。</p><pre tabindex=0><code>// Good:
/*
The seed_generator command is a utility that generates a Finch seed file
from a set of JSON study configs.

    seed_generator *.json | base64 &gt; finch-seed.base64
*/
package template
</code></pre></li><li><p>供维护者使用且适用于整个文件的注释通常放在导入声明之后。 这些不会出现在 Godoc 中，也不受上述包注释规则的约束。</p></li></ul><h2 id=导入>导入
<a class=anchor href=#%e5%af%bc%e5%85%a5>#</a></h2><h3 id=导入重命名>导入重命名
<a class=anchor href=#%e5%af%bc%e5%85%a5%e9%87%8d%e5%91%bd%e5%90%8d>#</a></h3><p>只有在为了避免与其他导入的名称冲突时，才使用重命名导入。 （由此推论，<a href=https://google.github.io/styleguide/go/decisions#package-names>好的包名称</a> 不需要重命名。）如果发生名称冲突，最好重命名 最本地或特定于项目的导入。 包的本地别名必须遵循<a href=https://google.github.io/styleguide/go/decisions#package-names>包命名指南</a>，包括禁止使用下划线和大写字母。</p><p>生成的 protocol buffer 包必须重命名以从其名称中删除下划线，并且它们的别名必须具有 <code>pb</code> 后缀。 有关详细信息，请参阅<a href=https://google.github.io/styleguide/go/best-practices#import-protos>proto和stub最佳实践</a>。</p><pre tabindex=0><code>// Good:
import (
    fspb &#34;path/to/package/foo_service_go_proto&#34;
)
</code></pre><p>导入的包名称没有有用的识别信息时（例如 <code>package v1</code>），应该重命名以包括以前的路径组件。 重命名必须与导入相同包的其他本地文件一致，并且可以包括版本号。</p><p><strong>注意：</strong> 最好重命名包以符合 <a href=https://google.github.io/styleguide/go/decisions#package-names>好的包命名规则</a>，但在vendor目录下的包通常是不可行的。</p><pre tabindex=0><code>// Good:
import (
    core &#34;github.com/kubernetes/api/core/v1&#34;
    meta &#34;github.com/kubernetes/apimachinery/pkg/apis/meta/v1beta1&#34;
)
</code></pre><p>如果您需要导入一个名称与您要使用的公共局部变量名称（例如 <code>url</code>、<code>ssh</code>）冲突的包，并且您希望重命名该包，首选方法是使用 <code>pkg</code> 后缀（例如 <code>urlpkg</code>）。 请注意，可以使用局部变量隐藏包； 仅当此类变量在范围内时仍需要使用此包时，才需要重命名。</p><h3 id=导入分组>导入分组
<a class=anchor href=#%e5%af%bc%e5%85%a5%e5%88%86%e7%bb%84>#</a></h3><p>导入应分为两组：</p><ul><li>标准库包</li><li>其他（项目和vendor）包</li></ul><pre tabindex=0><code>// Good:
package main

import (
    &#34;fmt&#34;
    &#34;hash/adler32&#34;
    &#34;os&#34;

    &#34;github.com/dsnet/compress/flate&#34;
    &#34;golang.org/x/text/encoding&#34;
    &#34;google.golang.org/protobuf/proto&#34;
    foopb &#34;myproj/foo/proto/proto&#34;
    _ &#34;myproj/rpc/protocols/dial&#34;
    _ &#34;myproj/security/auth/authhooks&#34;
)
</code></pre><p>将导入项分成多个组是可以接受的，例如，如果您想要一个单独的组来重命名、导入仅为了特殊效果 或另一个特殊的导入组。</p><pre tabindex=0><code>// Good:
package main

import (
    &#34;fmt&#34;
    &#34;hash/adler32&#34;
    &#34;os&#34;

    &#34;github.com/dsnet/compress/flate&#34;
    &#34;golang.org/x/text/encoding&#34;
    &#34;google.golang.org/protobuf/proto&#34;

    foopb &#34;myproj/foo/proto/proto&#34;

    _ &#34;myproj/rpc/protocols/dial&#34;
    _ &#34;myproj/security/auth/authhooks&#34;
)
</code></pre><p><strong>注意：</strong> <a href=https://google.github.io/styleguide/go/golang.org/x/tools/cmd/goimports>goimports</a> 不支持维护可选组 - 超出标准库和 Google 导入之间强制分离所需的拆分。为了保持符合状态，额外的导入子组需要作者和审阅人的注意。</p><p>Google 程序有时也是 AppEngine 应用程序，应该有一个单独的组用于 AppEngine 导入。</p><p>Gofmt 负责按导入路径对每个组进行排序。但是，它不会自动将导入分成组。流行的 <a href=https://google.github.io/styleguide/go/golang.org/x/tools/cmd/goimports>goimports</a> 工具结合了 Gofmt 和导入管理，根据上述规则将导入进行分组。通过 <a href=https://google.github.io/styleguide/go/golang.org/x/tools/cmd/goimports>goimports</a> 来管理导入安排是可行的，但随着文件的修改，其导入列表必须保持内部一致。</p><h3 id=导入空-import-_>导入"空" (<code>import _</code>)
<a class=anchor href=#%e5%af%bc%e5%85%a5%e7%a9%ba-import-_>#</a></h3><p>使用语法 <code>import _ "package"</code>导入的包，称为副作用导入，只能在主包或需要它们的测试中导入。</p><p>此类软件包的一些示例包括：</p><ul><li><a href=https://pkg.go.dev/time/tzdata>time/tzdata</a></li><li><a href=https://pkg.go.dev/image/jpeg>image/jpeg</a> 在图像处理中的代码</li></ul><p>避免在工具包中导入空白，即使工具包间接依赖于它们。 将副作用导入限制到主包有助于控制依赖性，并使得编写依赖于不同导入的测试成为可能，而不会发生冲突或浪费构建成本。</p><p>以下是此规则的唯一例外情况：</p><ul><li>您可以使用空白导入来绕过 <a href=https://github.com/bazelbuild/rules_go/blob/master/go/nogo.rst>nogo 静态检查器</a> 中对不允许导入的检查。</li><li>您可以在使用 <code>//go:embed</code> 编译器指令的源文件中使用 <a href=https://pkg.go.dev/embed>embed</a> 包的空白导入。</li></ul><p>**提示：**如果生产环境中您创建的工具包间接依赖于副作用导入，请记录这里的预期用途。</p><h3 id=导入--import->导入 “.” (<code>import .</code>)
<a class=anchor href=#%e5%af%bc%e5%85%a5--import->#</a></h3><p><code>import .</code> 形式是一种语言特性，它允许将从另一个包导出的标识符无条件地带到当前包中。 有关更多信息，请参阅<a href=https://go.dev/ref/spec#Import_declarations>语言规范</a>。</p><p><strong>不要</strong>在 Google 代码库中使用此功能； 这使得更难判断功能来自何处。</p><pre tabindex=0><code>// Bad:
package foo_test

import (
    &#34;bar/testutil&#34; // also imports &#34;foo&#34;
    . &#34;foo&#34;
)

var myThing = Bar() // Bar defined in package foo; no qualification needed.
// Good:
package foo_test

import (
    &#34;bar/testutil&#34; // also imports &#34;foo&#34;
    &#34;foo&#34;
)

var myThing = foo.Bar()
</code></pre><h2 id=错误>错误
<a class=anchor href=#%e9%94%99%e8%af%af>#</a></h2><h3 id=返回错误>返回错误
<a class=anchor href=#%e8%bf%94%e5%9b%9e%e9%94%99%e8%af%af>#</a></h3><p>使用 <code>error</code> 表示函数可能会失败。 按照惯例，<code>error</code> 是最后一个结果参数。</p><pre tabindex=0><code>// Good:
func Good() error { /* ... */ }
</code></pre><p>返回 <code>nil</code> 错误是表示操作成功的惯用方式，否则表示可能会失败。 如果函数返回错误，除非另有明确说明，否则调用者必须将所有非错误返回值视为未确定。 通常来说，非错误返回值是它们的零值，但也不能直接这么假设。</p><pre tabindex=0><code>// Good:
func GoodLookup() (*Result, error) {
    // ...
    if err != nil {
        return nil, err
    }
    return res, nil
}
</code></pre><p>返回错误的导出函数应使用<code>error</code>类型返回它们。 具体的错误类型容易受到细微错误的影响：一个 <code>nil</code> 指针可以包装到接口中，从而就变成非 nil 值（参见 <a href=https://golang.org/doc/faq#nil_error>关于该主题的 Go FAQ 条目</a>）。</p><pre tabindex=0><code>// Bad:
func Bad() *os.PathError { /*...*/ }
</code></pre><p><strong>提示</strong>：采用 <code>context.Context</code> 参数的函数通常应返回 <code>error</code>，以便调用者可以确定上下文是否在函数运行时被取消。</p><h3 id=错误字符串>错误字符串
<a class=anchor href=#%e9%94%99%e8%af%af%e5%ad%97%e7%ac%a6%e4%b8%b2>#</a></h3><p>错误字符串不应大写（除非以导出名称、专有名词或首字母缩写词开头）并且不应以标点符号结尾。 这是因为错误字符串通常在打印给用户之前出现在其他上下文中。</p><pre tabindex=0><code>// Bad:
err := fmt.Errorf(&#34;Something bad happened.&#34;)
// Good:
err := fmt.Errorf(&#34;something bad happened&#34;)
</code></pre><p>另一方面，完整显示消息（日志记录、测试失败、API 响应或其他 UI）的样式视情况而定，但通常应大写首字母。</p><pre tabindex=0><code>// Good:
log.Infof(&#34;Operation aborted: %v&#34;, err)
log.Errorf(&#34;Operation aborted: %v&#34;, err)
t.Errorf(&#34;Op(%q) failed unexpectedly; err=%v&#34;, args, err)
</code></pre><h3 id=错误处理>错误处理
<a class=anchor href=#%e9%94%99%e8%af%af%e5%a4%84%e7%90%86>#</a></h3><p>遇到错误的代码应该慎重选择如何处理它。 使用 _ 变量丢弃错误通常是不合适的。 如果函数返回错误，请执行以下操作之一：</p><ul><li>立即处理并解决错误</li><li>将错误返回给调用者</li><li>在特殊情况下，调用 <a href=https://pkg.go.dev/github.com/golang/glog#Fatal><code>log.Fatal</code></a> 或（如绝对有必要）则调用 <code>panic</code></li></ul><p><strong>注意：</strong> <code>log.Fatalf</code> 不是标准库日志。 参见 [#logging]。</p><p>在极少数情况下适合忽略或丢弃错误（例如调用 <a href=https://pkg.go.dev/bytes#Buffer.Write><code>(*bytes.Buffer).Write</code></a> 被记录为永远不会失败），随附的注释应该解释为什么这是安全的。</p><pre tabindex=0><code>// Good:
var b *bytes.Buffer

n, _ := b.Write(p) // never returns a non-nil error
</code></pre><p>关于错误处理的更多讨论和例子，请参见<a href=http://golang.org/doc/effective_go.html#errors>Effective Go</a>和<a href=https://google.github.io/styleguide/go/best-practices.html#error-handling>最佳实践</a>。</p><h3 id=in-band-错误>In-band 错误
<a class=anchor href=#in-band-%e9%94%99%e8%af%af>#</a></h3><p>在C和类似语言中，函数通常会返回-1、null或空字符串等值，以示错误或丢失结果。这就是所谓的带内<code>In-band</code>处理。</p><pre tabindex=0><code>// Bad:
// Lookup returns the value for key or -1 if there is no mapping for key.
func Lookup(key string) int
</code></pre><p>未能检查<code>In-band</code>错误值会导致错误，并可能将error归于错误的功能。</p><pre tabindex=0><code>// Bad:
// The following line returns an error that Parse failed for the input value,
// whereas the failure was that there is no mapping for missingKey.
return Parse(Lookup(missingKey))
</code></pre><p>Go对多重返回值的支持提供了一个更好的解决方案（见<a href=http://golang.org/doc/effective_go.html#multiple-returns>Effective Go关于多重返回的部分</a>）。与其要求调用方检查<code>In-band</code>的错误值，函数更应该返回一个额外的值来表明返回值是否有效。这个返回值可以是一个错误，或者在不需要解释时是一个布尔值，并且应该是最终的返回值。</p><pre tabindex=0><code>// Good:
// Lookup returns the value for key or ok=false if there is no mapping for key.
func Lookup(key string) (value string, ok bool)
</code></pre><p>这个API可以防止调用者错误地编写<code>Parse(Lookup(key))</code>，从而导致编译时错误，因为<code>Lookup(key)</code>有两个返回值。</p><p>以这种方式返回错误，可以鼓励更强大和明确的错误处理。</p><pre tabindex=0><code>// Good:
value, ok := Lookup(key)
if !ok {
    return fmt.Errorf(&#34;no value for %q&#34;, key)
}
return Parse(value)
</code></pre><p>一些标准库函数，如包<code>strings</code>中的函数，返回<code>In-band</code>错误值。这大大简化了字符串处理的代码，但代价是要求程序员更加勤奋。一般来说，Google代码库中的Go代码应该为错误返回额外的值。</p><h3 id=缩进错误流程>缩进错误流程
<a class=anchor href=#%e7%bc%a9%e8%bf%9b%e9%94%99%e8%af%af%e6%b5%81%e7%a8%8b>#</a></h3><p>在继续代码的其余部分之前处理错误。这提高了代码的可读性，使读者能够快速找到正常路径。这个逻辑同样适用于任何测试条件并以终端条件结束的代码块（例如，<code>return</code>、<code>panic</code>、<code>log.Fatal</code>）。</p><p>如果终止条件没有得到满足，运行的代码应该出现在<code>if</code>块之后，而不应该缩进到<code>else</code>子句中。</p><pre tabindex=0><code>// Good:
if err != nil {
    // error handling
    return // or continue, etc.
}
// normal code
// Bad:
if err != nil {
    // error handling
} else {
    // normal code that looks abnormal due to indentation
}
</code></pre><blockquote><p>**提示：**如果你使用一个变量超过几行代码，通常不值得使用<code>带有初始化的if</code>风格。在这种情况下，通常最好将声明移出，使用标准的<code>if</code>语句。</p><pre tabindex=0><code>// Good:
x, err := f()
if err != nil {
  // error handling
  return
}
// lots of code that uses x
// across multiple lines
// Bad:
if x, err := f(); err != nil {
  // error handling
  return
} else {
  // lots of code that uses x
  // across multiple lines
}
</code></pre></blockquote><p>更多细节见<a href=https://google.github.io/styleguide/go/index.html#gotip>Go Tip #1：视线</a>和<a href=https://testing.googleblog.com/2017/06/code-health-reduce-nesting-reduce.html>TotT：通过减少嵌套降低代码的复杂性</a>。</p><h2 id=语言>语言
<a class=anchor href=#%e8%af%ad%e8%a8%80>#</a></h2><h3 id=字面格式化>字面格式化
<a class=anchor href=#%e5%ad%97%e9%9d%a2%e6%a0%bc%e5%bc%8f%e5%8c%96>#</a></h3><p>Go有一个非常强大的<a href=https://golang.org/ref/spec#Composite_literals>复合字面语法</a>，用它可以在一个表达式中表达深度嵌套的复杂值。在可能的情况下，应该使用这种字面语法，而不是逐字段建值。字面意义的 <code>gofmt</code>格式一般都很好，但有一些额外的规则可以使这些字面意义保持可读和可维护。</p><h4 id=字段名称>字段名称
<a class=anchor href=#%e5%ad%97%e6%ae%b5%e5%90%8d%e7%a7%b0>#</a></h4><p>对于在当前包之外定义的类型，结构体字面量通常应该指定<strong>字段名</strong>。</p><ul><li><p>包括来自其他包的类型的字段名。</p><pre tabindex=0><code>// Good:
good := otherpkg.Type{A: 42}
</code></pre><p>结构中字段的位置和字段的完整集合（当字段名被省略时，这两者都是有必要搞清楚的）通常不被认为是结构的公共API的一部分；需要指定字段名以避免不必要的耦合。</p><pre tabindex=0><code>// Bad:
// https://pkg.go.dev/encoding/csv#Reader
r := csv.Reader{&#39;,&#39;, &#39;#&#39;, 4, false, false, false, false}
</code></pre><p>在小型、简单的结构中可以省略字段名，这些结构的组成和顺序都有文档证明是稳定的。</p><pre tabindex=0><code>// Good:
okay := image.Point{42, 54}
also := image.Point{X: 42, Y: 54}
</code></pre></li><li><p>对于包内类型，字段名是可选的。</p><pre tabindex=0><code>// Good:
okay := Type{42}
also := internalType{4, 2}
</code></pre><p>如果能使代码更清晰，还是应该使用字段名，而且这样做是很常见的。例如，一个有大量字段的结构几乎都应该用字段名来初始化。</p><pre tabindex=0><code>// Good:
okay := StructWithLotsOfFields{
  field1: 1,
  field2: &#34;two&#34;,
  field3: 3.14,
  field4: true,
}
</code></pre></li></ul><h4 id=匹配的大括号>匹配的大括号
<a class=anchor href=#%e5%8c%b9%e9%85%8d%e7%9a%84%e5%a4%a7%e6%8b%ac%e5%8f%b7>#</a></h4><p>一对大括号的最后一半应该总是出现在一行中，其缩进量与开头的大括号相同。单行字词必然具有这个属性。当字面意义跨越多行时，保持这一属性可以使字面意义的括号匹配与函数和<code>if</code>语句等常见Go语法结构的括号匹配相同。</p><p>这方面最常见的错误是在多行结构字中把收尾括号与值放在同一行。在这种情况下，该行应以逗号结束，收尾括号应出现在下一行。</p><pre tabindex=0><code>// Good:
good := []*Type{{Key: &#34;value&#34;}}
// Good:
good := []*Type{
    {Key: &#34;multi&#34;},
    {Key: &#34;line&#34;},
}
// Bad:
bad := []*Type{
    {Key: &#34;multi&#34;},
    {Key: &#34;line&#34;}}
// Bad:
bad := []*Type{
    {
        Key: &#34;value&#34;},
}
</code></pre><h4 id=cuddled-大括号>Cuddled 大括号
<a class=anchor href=#cuddled-%e5%a4%a7%e6%8b%ac%e5%8f%b7>#</a></h4><p>只有在以下两种情况下，才允许在大括号之间为切片和数组丢弃空格（又称 &ldquo;“cuddling”）。</p><ul><li><a href=https://google.github.io/styleguide/go/decisions#literal-matching-braces>缩进匹配</a></li><li>内部值也是字面意义或原语构建者（即不是变量或其他表达式）</li></ul><pre tabindex=0><code>// Good:
good := []*Type{
    { // Not cuddled
        Field: &#34;value&#34;,
    },
    {
        Field: &#34;value&#34;,
    },
}
// Good:
good := []*Type{{ // Cuddled correctly
    Field: &#34;value&#34;,
}, {
    Field: &#34;value&#34;,
}}
// Good:
good := []*Type{
    first, // Can&#39;t be cuddled
    {Field: &#34;second&#34;},
}
// Good:
okay := []*pb.Type{pb.Type_builder{
    Field: &#34;first&#34;, // Proto Builders may be cuddled to save vertical space
}.Build(), pb.Type_builder{
    Field: &#34;second&#34;,
}.Build()}
// Bad:
bad := []*Type{
    first,
    {
        Field: &#34;second&#34;,
    }}
</code></pre><h4 id=重复的类型名称>重复的类型名称
<a class=anchor href=#%e9%87%8d%e5%a4%8d%e7%9a%84%e7%b1%bb%e5%9e%8b%e5%90%8d%e7%a7%b0>#</a></h4><p>重复的类型名称可以从slice和map字面上省略，这对减少杂乱是有帮助的。明确重复类型名称的一个合理场合，当在你的项目中处理一个不常见的复杂类型时，当重复的类型名称在相隔很远的行上时，可以提醒读者的上下文。</p><pre tabindex=0><code>// Good:
good := []*Type{
    {A: 42},
    {A: 43},
}
// Bad:
repetitive := []*Type{
    &amp;Type{A: 42},
    &amp;Type{A: 43},
}
// Good:
good := map[Type1]*Type2{
    {A: 1}: {B: 2},
    {A: 3}: {B: 4},
}
// Bad:
repetitive := map[Type1]*Type2{
    Type1{A: 1}: &amp;Type2{B: 2},
    Type1{A: 3}: &amp;Type2{B: 4},
}
</code></pre><p>**提示：**如果你想删除结构字中重复的类型名称，可以运行<code>gofmt -s</code>。</p><h4 id=零值字段>零值字段
<a class=anchor href=#%e9%9b%b6%e5%80%bc%e5%ad%97%e6%ae%b5>#</a></h4><p><a href=https://golang.org/ref/spec#The_zero_value>零值</a>字段可以从结构字段中省略，但不能因此而失去清晰度。</p><p>设计良好的API经常采用零值结构来提高可读性。例如，从下面的结构中省略三个零值字段，可以使人们注意到正在指定的唯一选项。</p><pre tabindex=0><code>// Bad:
import (
  &#34;github.com/golang/leveldb&#34;
  &#34;github.com/golang/leveldb/db&#34;
)

ldb := leveldb.Open(&#34;/my/table&#34;, &amp;db.Options{
    BlockSize int: 1&lt;&lt;16,
    ErrorIfDBExists: true,

    // These fields all have their zero values.
    BlockRestartInterval: 0,
    Comparer: nil,
    Compression: nil,
    FileSystem: nil,
    FilterPolicy: nil,
    MaxOpenFiles: 0,
    WriteBufferSize: 0,
    VerifyChecksums: false,
})
// Good:
import (
  &#34;github.com/golang/leveldb&#34;
  &#34;github.com/golang/leveldb/db&#34;
)

ldb := leveldb.Open(&#34;/my/table&#34;, &amp;db.Options{
    BlockSize int: 1&lt;&lt;16,
    ErrorIfDBExists: true,
})
</code></pre><p>表驱动的测试中的结构经常受益于<a href=https://google.github.io/styleguide/go/decisions#literal-field-names>显式字段名</a>，特别是当测试结构不是琐碎的时候。这允许作者在有关字段与测试用例无关时完全省略零值字段。例如，成功的测试案例应该省略任何与错误或失败相关的字段。在零值对于理解测试用例是必要的情况下，例如测试零或 <code>nil</code> 输入，应该指定字段名。</p><p><strong>简明</strong></p><pre tabindex=0><code>tests := []struct {
    input      string
    wantPieces []string
    wantErr    error
}{
    {
        input:      &#34;1.2.3.4&#34;,
        wantPieces: []string{&#34;1&#34;, &#34;2&#34;, &#34;3&#34;, &#34;4&#34;},
    },
    {
        input:   &#34;hostname&#34;,
        wantErr: ErrBadHostname,
    },
}
</code></pre><p><strong>明确</strong></p><pre tabindex=0><code>tests := []struct {
    input    string
    wantIPv4 bool
    wantIPv6 bool
    wantErr  bool
}{
    {
        input:    &#34;1.2.3.4&#34;,
        wantIPv4: true,
        wantIPv6: false,
    },
    {
        input:    &#34;1:2::3:4&#34;,
        wantIPv4: false,
        wantIPv6: true,
    },
    {
        input:    &#34;hostname&#34;,
        wantIPv4: false,
        wantIPv6: false,
        wantErr:  true,
    },
}
</code></pre><h3 id=nil-切片>Nil 切片
<a class=anchor href=#nil-%e5%88%87%e7%89%87>#</a></h3><p>在大多数情况下，<code>nil</code>和空切片之间没有功能上的区别。像<code>len</code>和<code>cap</code>这样的内置函数在<code>nil</code>片上的表现与预期相同。</p><pre tabindex=0><code>// Good:
import &#34;fmt&#34;

var s []int         // nil

fmt.Println(s)      // []
fmt.Println(len(s)) // 0
fmt.Println(cap(s)) // 0
for range s {...}   // no-op

s = append(s, 42)
fmt.Println(s)      // [42]
</code></pre><p>如果你声明一个空片作为局部变量（特别是如果它可以成为返回值的来源），最好选择nil初始化，以减少调用者的错误风险。</p><pre tabindex=0><code>// Good:
var t []string
// Bad:
t := []string{}
</code></pre><p>不要创建强迫调用者区分nil和空片的API。</p><pre tabindex=0><code>// Good:
// Ping pings its targets.
// Returns hosts that successfully responded.
func Ping(hosts []string) ([]string, error) { ... }
// Bad:
// Ping pings its targets and returns a list of hosts
// that successfully responded. Can be empty if the input was empty.
// nil signifies that a system error occurred.
func Ping(hosts []string) []string { ... }
</code></pre><p>在设计接口时，避免区分 <code>nil</code> 切片和非 <code>nil</code> 的零长度分片，因为这可能导致微妙的编程错误。这通常是通过使用<code>len</code>来检查是否为空，而不是<code>==nil</code>来实现的。</p><p>这个实现同时接受<code>nil</code>和零长度的片子为 &ldquo;空&rdquo;。</p><pre tabindex=0><code>// Good:
// describeInts describes s with the given prefix, unless s is empty.
func describeInts(prefix string, s []int) {
    if len(s) == 0 {
        return
    }
    fmt.Println(prefix, s)
}
</code></pre><p>而不是依靠二者的区别作为API的一部分：</p><pre tabindex=0><code>// Bad:
func maybeInts() []int { /* ... */ }

// describeInts describes s with the given prefix; pass nil to skip completely.
func describeInts(prefix string, s []int) {
  // The behavior of this function unintentionally changes depending on what
  // maybeInts() returns in &#39;empty&#39; cases (nil or []int{}).
  if s == nil {
    return
  }
  fmt.Println(prefix, s)
}

describeInts(&#34;Here are some ints:&#34;, maybeInts())
</code></pre><p>详见 <a href=https://google.github.io/styleguide/go/decisions#in-band-errors>in-band 错误</a>.</p><h3 id=缩进的混乱>缩进的混乱
<a class=anchor href=#%e7%bc%a9%e8%bf%9b%e7%9a%84%e6%b7%b7%e4%b9%b1>#</a></h3><p>如果断行会使其余的行与缩进的代码块对齐，则应避免引入断行。如果这是不可避免的，请留下一个空间，将代码块中的代码与包线分开。</p><pre tabindex=0><code>// Bad:
if longCondition1 &amp;&amp; longCondition2 &amp;&amp;
    // Conditions 3 and 4 have the same indentation as the code within the if.
    longCondition3 &amp;&amp; longCondition4 {
    log.Info(&#34;all conditions met&#34;)
}
</code></pre><p>具体准则和例子见以下章节：</p><ul><li><a href=https://google.github.io/styleguide/go/decisions#func-formatting>Function formatting</a></li><li><a href=https://google.github.io/styleguide/go/decisions#conditional-formatting>Conditionals and loops</a></li><li><a href=https://google.github.io/styleguide/go/decisions#literal-formatting>Literal formatting</a></li></ul><h3 id=函数格式化>函数格式化
<a class=anchor href=#%e5%87%bd%e6%95%b0%e6%a0%bc%e5%bc%8f%e5%8c%96>#</a></h3><p>函数或方法声明的签名应该保持在一行，以避免<a href=https://google.github.io/styleguide/go/decisions#indentation-confusion>缩进的混乱</a>。</p><p>函数参数列表可以成为Go源文件中最长的几行。然而，它们在缩进的变化之前，因此很难以不使后续行看起来像函数体的一部分的方式来断行，从而造成混乱。</p><pre tabindex=0><code>// Bad:
func (r *SomeType) SomeLongFunctionName(foo1, foo2, foo3 string,
    foo4, foo5, foo6 int) {
    foo7 := bar(foo1)
    // ...
}
</code></pre><p>参见<a href=https://google.github.io/styleguide/go/best-practices#funcargs>最佳实践</a>，了解一些缩短函数调用的选择，否则这些函数会有很多参数。</p><pre tabindex=0><code>// Good:
good := foo.Call(long, CallOptions{
    Names:   list,
    Of:      of,
    The:     parameters,
    Func:    all,
    Args:    on,
    Now:     separate,
    Visible: lines,
})
// Bad:
bad := foo.Call(
    long,
    list,
    of,
    parameters,
    all,
    on,
    separate,
    lines,
)
</code></pre><p>通过分解局部变量，通常可以缩短行数。</p><pre tabindex=0><code>// Good:
local := helper(some, parameters, here)
good := foo.Call(list, of, parameters, local)
</code></pre><p>类似地，函数和方法调用不应该仅仅由于行的长度而进行换行。</p><pre tabindex=0><code>// Good:
good := foo.Call(long, list, of, parameters, all, on, one, line)
// Bad:
bad := foo.Call(long, list, of, parameters,
    with, arbitrary, line, breaks)
</code></pre><p>不要为特定的函数参数添加注释。 相反，使用 <a href=https://google.github.io/styleguide/go/best-practices#option-structure>option struct</a> 或在函数文档中添加更多细节。</p><pre tabindex=0><code>// Good:
good := server.New(ctx, server.Options{Port: 42})
// Bad:
bad := server.New(
    ctx,
    42, // Port
)
</code></pre><p>如果调用参数确实长得令人很难受，那么就应该考虑重构：</p><pre tabindex=0><code>// Good:
// Sometimes variadic arguments can be factored out
replacements := []string{
    &#34;from&#34;, &#34;to&#34;, // related values can be formatted adjacent to one another
    &#34;source&#34;, &#34;dest&#34;,
    &#34;original&#34;, &#34;new&#34;,
}

// Use the replacement struct as inputs to NewReplacer.
replacer := strings.NewReplacer(replacements...)
</code></pre><p>当 API 无法更改或本地调用是不寻常的（无论调用是否太长），如果有助于理解本次调用，始终允许添加换行符。</p><pre tabindex=0><code>// Good:
canvas.RenderCube(cube,
    x0, y0, z0,
    x0, y0, z1,
    x0, y1, z0,
    x0, y1, z1,
    x1, y0, z0,
    x1, y0, z1,
    x1, y1, z0,
    x1, y1, z1,
)
</code></pre><p>请注意，上面示例中的行没有在特定的列边界处换行，而是根据坐标三元组进行分组。</p><p>函数中的长字符串不应该因为行的长度而被破坏。 对于包含此类字符串的函数，可以在字符串格式之后添加换行符，并且可以在下一行或后续行中提供参数。 最好根据输入的语义分组来决定换行符应该放在哪里，而不是单纯基于行长。</p><pre tabindex=0><code>// Good:
log.Warningf(&#34;Database key (%q, %d, %q) incompatible in transaction started by (%q, %d, %q)&#34;,
    currentCustomer, currentOffset, currentKey,
    txCustomer, txOffset, txKey)
// Bad:
log.Warningf(&#34;Database key (%q, %d, %q) incompatible in&#34;+
    &#34; transaction started by (%q, %d, %q)&#34;,
    currentCustomer, currentOffset, currentKey, txCustomer,
    txOffset, txKey)
</code></pre><h3 id=条件和循环>条件和循环
<a class=anchor href=#%e6%9d%a1%e4%bb%b6%e5%92%8c%e5%be%aa%e7%8e%af>#</a></h3><p><code>if</code> 语句不应换行； 多行 <code>if</code> 子句的形式会出现 <a href=https://google.github.io/styleguide/go/decisions#indentation-confusion>缩进混乱带来的困扰</a>。</p><pre tabindex=0><code>// Bad:
// The second if statement is aligned with the code within the if block, causing
// indentation confusion.
if db.CurrentStatusIs(db.InTransaction) &amp;&amp;
    db.ValuesEqual(db.TransactionKey(), row.Key()) {
    return db.Errorf(db.TransactionError, &#34;query failed: row (%v): key does not match transaction key&#34;, row)
}
</code></pre><p>如果不需要短路(short-circuit)行为，可以直接提取布尔操作数：</p><pre tabindex=0><code>// Good:
inTransaction := db.CurrentStatusIs(db.InTransaction)
keysMatch := db.ValuesEqual(db.TransactionKey(), row.Key())
if inTransaction &amp;&amp; keysMatch {
    return db.Error(db.TransactionError, &#34;query failed: row (%v): key does not match transaction key&#34;, row)
}
</code></pre><p>尤其注意，在条件已经重复的情况下，很可能还是有可以提取的局部变量：</p><pre tabindex=0><code>// Good:
uid := user.GetUniqueUserID()
if db.UserIsAdmin(uid) || db.UserHasPermission(uid, perms.ViewServerConfig) || db.UserHasPermission(uid, perms.CreateGroup) {
    // ...
}
// Bad:
if db.UserIsAdmin(user.GetUniqueUserID()) || db.UserHasPermission(user.GetUniqueUserID(), perms.ViewServerConfig) || db.UserHasPermission(user.GetUniqueUserID(), perms.CreateGroup) {
    // ...
}
</code></pre><p>包含闭包或多行结构文字的 <code>if</code> 语句应确保 <a href=https://google.github.io/styleguide/go/decisions#literal-matching-braces>大括号匹配</a> 以避免 [缩进混淆] （https://google.github.io/styleguide/go/decisions#indentation-confusion）。</p><pre tabindex=0><code>// Good:
if err := db.RunInTransaction(func(tx *db.TX) error {
    return tx.Execute(userUpdate, x, y, z)
}); err != nil {
    return fmt.Errorf(&#34;user update failed: %s&#34;, err)
}
// Good:
if _, err := client.Update(ctx, &amp;upb.UserUpdateRequest{
    ID:   userID,
    User: user,
}); err != nil {
    return fmt.Errorf(&#34;user update failed: %s&#34;, err)
}
</code></pre><p>同样，不要尝试在 <code>for</code> 语句中人为的插入换行符。 如果没有优雅的重构方式，是可以允许单纯的较长的行：</p><pre tabindex=0><code>// Good:
for i, max := 0, collection.Size(); i &lt; max &amp;&amp; !collection.HasPendingWriters(); i++ {
    // ...
}
</code></pre><p>但是，通常可以优化为：</p><pre tabindex=0><code>// Good:
for i, max := 0, collection.Size(); i &lt; max; i++ {
    if collection.HasPendingWriters() {
        break
    }
    // ...
}
</code></pre><p><code>switch</code> 和 <code>case</code> 语句都应始终保持在一行：</p><pre tabindex=0><code>// Good:
switch good := db.TransactionStatus(); good {
case db.TransactionStarting, db.TransactionActive, db.TransactionWaiting:
    // ...
case db.TransactionCommitted, db.NoTransaction:
    // ...
default:
    // ...
}
// Bad:
switch bad := db.TransactionStatus(); bad {
case db.TransactionStarting,
    db.TransactionActive,
    db.TransactionWaiting:
    // ...
case db.TransactionCommitted,
    db.NoTransaction:
    // ...
default:
    // ...
}
</code></pre><p>如果行太长，将所有大小写缩进并用空行分隔以避免[缩进混淆]（https://google.github.io/styleguide/go/decisions#indentation-confusion）：</p><pre tabindex=0><code>// Good:
switch db.TransactionStatus() {
case
    db.TransactionStarting,
    db.TransactionActive,
    db.TransactionWaiting,
    db.TransactionCommitted:

    // ...
case db.NoTransaction:
    // ...
default:
    // ...
}
</code></pre><p>在将变量比较的条件中，变量值放在等号运算符的左侧：</p><pre tabindex=0><code>// Good:
if result == &#34;foo&#34; {
  // ...
}
</code></pre><p>不要采用常量在前的表达含糊的条件写法(<a href=https://en.wikipedia.org/wiki/Yoda_conditions>尤达条件式</a>)</p><pre tabindex=0><code>// Bad:
if &#34;foo&#34; == result {
  // ...
}
</code></pre><h3 id=复制>复制
<a class=anchor href=#%e5%a4%8d%e5%88%b6>#</a></h3><p>为了避免意外的别名和类似的错误，从另一个包复制结构时要小心。 例如 <code>sync.Mutex</code> 是不能复制的同步对象，</p><p><code>bytes.Buffer</code> 类型包含一个 <code>[]byte</code> 切片和切片可以引用的小数组，这是为了对小字符串的优化。 如果你复制一个 <code>Buffer</code>，复制的切片会指向原始切片中的数组，从而在后续方法调用产生意外的效果。</p><p>一般来说，如果类型的方法与指针类型<code>*T</code>相关联，不要复制类型为<code>T</code>的值。</p><pre tabindex=0><code>// Bad:
b1 := bytes.Buffer{}
b2 := b1
</code></pre><p>调用值接收者的方法可以隐藏副本。 当您编写 API 时，如果您的结构包含不应复制的字段，您通常应该采用并返回指针类型。</p><p>如此是可接受的:</p><pre tabindex=0><code>// Good:
type Record struct {
  buf bytes.Buffer
  // other fields omitted
}

func New() *Record {...}

func (r *Record) Process(...) {...}

func Consumer(r *Record) {...}
</code></pre><p>但下面这种通常是错误的:</p><pre tabindex=0><code>// Bad:
type Record struct {
  buf bytes.Buffer
  // other fields omitted
}

func (r Record) Process(...) {...} // Makes a copy of r.buf

func Consumer(r Record) {...} // Makes a copy of r.buf
</code></pre><p>这一指南同样也适用于 <code>sync.Mutex</code> 复制的情况。</p><h3 id=不要-panic>不要 panic
<a class=anchor href=#%e4%b8%8d%e8%a6%81-panic>#</a></h3><p>不要使用 <code>panic</code> 进行正常的错误处理。 相反，使用 <code>error</code> 和多个返回值。 请参阅 <a href=http://golang.org/doc/effective_go.html#errors>关于错误的有效 Go 部分</a>。</p><p>在 <code>package main</code> 和初始化代码中，考虑 <a href=https://pkg.go.dev/github.com/golang/glog#Exit><code>log.Exit</code></a> 中应该终止程序的错误（例如，无效配置 )，因为在许多这些情况下，堆栈跟踪对阅读者没有帮助。 请注意 <a href=https://pkg.go.dev/github.com/golang/glog#Exit><code>log.Exit</code></a> 中调用了 <a href=https://pkg.go.dev/os#Exit><code>os.Exit</code></a> ，此时所有<code>defer</code>函数都将不会运行。</p><p>对于那些表示“不可能”出现的条件错误、命名错误，应该在代码评审、测试期间发现，函数应合理地返回错误或调用 [<code>log.Fatal</code>](<a href=https://pkg.go.dev>https://pkg.go.dev</a> /github.com/golang/glog#Fatal）。</p><p><strong>注意：</strong> <code>log.Fatalf</code> 不是标准库日志。 请参阅 [#logging]。</p><h3 id=must类函数>Must类函数
<a class=anchor href=#must%e7%b1%bb%e5%87%bd%e6%95%b0>#</a></h3><p>用于在失败时停止程序的辅助函数应遵循命名约定“MustXYZ”（或“mustXYZ”）。 一般来说，它们应该只在程序启动的早期被调用，而不是在像用户输入时，此时更应该首选 <code>error</code> 处理。</p><p>这类方式，通常只在[包初始化时]（https://golang.org/ref/spec#Package_initialization）进行包级变量初始化的函数常见（例如<a href=https://golang.org/pkg/text/template/#Must>template.Must</a> 和 <a href=https://golang.org/pkg/regexp/#MustCompile>regexp.MustCompile</a>)。</p><pre tabindex=0><code>// Good:
func MustParse(version string) *Version {
    v, err := Parse(version)
    if err != nil {
        log.Fatalf(&#34;MustParse(%q) = _, %v&#34;, version, err)
    }
    return v
}

// Package level &#34;constant&#34;. If we wanted to use `Parse`, we would have had to
// set the value in `init`.
var DefaultVersion = MustParse(&#34;1.2.3&#34;)
</code></pre><p>相同的约定也可用于仅停止当前测试的情况（使用 <code>t.Fatal</code>）。 这样在创建测试时通常很方便，例如在 <a href=https://google.github.io/styleguide/go/decisions#table-driven-tests>表驱动测试</a> 的结构字段中，作为返回错误的函数是不能直接复制给结构字段的。</p><pre tabindex=0><code>// Good:
func mustMarshalAny(t *testing.T, m proto.Message) *anypb.Any {
  t.Helper()
  any, err := anypb.New(m)
  if err != nil {
    t.Fatalf(&#34;MustMarshalAny(t, m) = %v; want %v&#34;, err, nil)
  }
  return any
}

func TestCreateObject(t *testing.T) {
  tests := []struct{
    desc string
    data *anypb.Any
  }{
    {
      desc: &#34;my test case&#34;,
      // Creating values directly within table driven test cases.
      data: mustMarshalAny(t, mypb.Object{}),
    },
    // ...
  }
  // ...
}
</code></pre><p>在这两种情况下，这种模式的价值在于可以在“值”上下文中调用。不应在难以确保捕获错误的地方或应<a href=https://google.github.io/styleguide/go/decisions#handle-errors>检查</a>错误的上下文中调用这些程序（如，在许多请求处理程序中）。对于常量输入，这允许测试确保“必须”的参数格式正确，对于非常量的输入，它允许测试验证错误是否<a href=https://google.github.io/styleguide/go/best-practices#error-handling>正确处理或传播</a>。</p><p>在测试中使用 <code>Must</code> 函数的地方，通常应该 <a href=https://google.github.io/styleguide/go/decisions#mark-test-helpers>标记为测试助手</a> 并调用 <code>t.Fatal</code>（请参阅<a href=https://google.github.io/styleguide/go/best-practices#test-helper-error-handling>测试助手中的错误处理</a>来了解使用它的更多注意事项）。</p><p>当有可能通过 <a href=https://google.github.io/styleguide/go/best-practices#error-handling>普通错误处理</a> 处理时，就不应该使用<code>Must</code>类函数：</p><pre tabindex=0><code>// Bad:
func Version(o *servicepb.Object) (*version.Version, error) {
    // Return error instead of using Must functions.
    v := version.MustParse(o.GetVersionString())
    return dealiasVersion(v)
}
</code></pre><h3 id=goroutine-生命周期>Goroutine 生命周期
<a class=anchor href=#goroutine-%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f>#</a></h3><p>当你生成 goroutines 时，要明确它们何时或是否退出。</p><p>Goroutines 可以在阻塞通道发送或接收出现泄漏。 垃圾收集器不会终止一个 goroutine，即使它被阻塞的通道已经不可用。</p><p>即使 goroutine 没有泄漏，在不再需要时仍处于运行状态也会导致其他微妙且难以诊断的问题。 向已关闭的通道上发送会导致panic。</p><pre tabindex=0><code>// Bad:
ch := make(chan int)
ch &lt;- 42
close(ch)
ch &lt;- 13 // panic
</code></pre><p>“在结果已经不需要之后”修改仍在使用的入参可能会导致数据竞争。 运行任意长时间的 goroutine 会导致不可预测的内存占用。</p><p>并发代码的编写应该让 goroutine 生命周期非常明显。 通常，这意味着在与同步相关的代码限制的函数范围内，将逻辑分解为 <a href=https://google.github.io/styleguide/go/decisions#synchronous-functions>同步函数</a>。 如果并发性仍然不明显，那么文档说明 goroutine 在何时、为何退出就很重要。</p><p>遵循上下文使用最佳实践的代码通常有助于明确这一点，其通常使用 <code>context.Context</code> 进行管理：</p><pre tabindex=0><code>// Good:
func (w *Worker) Run(ctx context.Context) error {
    // ...
    for item := range w.q {
        // process 至少在ctx取消时会返回
        go process(ctx, item)
    }
    // ...
}
</code></pre><p>上面还有其他使用通道的情况，例如 <code>chan struct{}</code>、同步变量、<a href=https://drive.google.com/file/d/1nPdvhB0PutEJzdCq5ms6UI58dp50fcAN/view>条件变量</a> 等等。 重要的部分是 goroutine 的终结对于后续维护者来说是显而易见的。</p><p>相比之下，以下代码不关心其衍生的 goroutine 何时完成：</p><pre tabindex=0><code>// Bad:
func (w *Worker) Run() {
    // ...
    for item := range w.q {
        // process returns when it finishes, if ever, possibly not cleanly
        // handling a state transition or termination of the Go program itself.
        go process(item)
    }
    // ...
}
</code></pre><p>这段代码看起来还行，但有几个潜在的问题：</p><ul><li>代码在可能会有未知的行为，即使操作系统已经释放资源，程序也可能没有完全干净地结束</li><li>由于代码的不确定生命周期，代码难以进行有效的测试</li><li>代码可能会出现资源泄漏，如上所述</li></ul><p>更多可阅读：</p><ul><li><a href=https://dave.cheney.net/2016/12/22/never-start-a-goroutine-without-knowing-how-it-will-stop>永远不要在不知道它将如何停止的情况下启动 goroutine</a></li><li>重新思考经典并发模式：<a href=https://drive.google.com/file/d/1nPdvhB0PutEJzdCq5ms6UI58dp50fcAN/view>幻灯片</a>，<a href="https://www.youtube.com/watch?v=5zXAHh5tJqQ">视频</a></li><li><a href=https://changelog.com/gotime/165>Go 程序何时结束</a></li></ul><h3 id=接口>接口
<a class=anchor href=#%e6%8e%a5%e5%8f%a3>#</a></h3><p>Go 接口通常属于<em>使用</em>接口类型值的包，而不是<em>实现</em>接口类型的包。实现包应该返回具体的（通常是指针或结构）类型。这样就可以将新方法添加到实现中，而无需进行大量重构。有关详细信息，请参阅 <a href=https://google.github.io/styleguide/go/index.html#gotip>GoTip #49：接受接口、返回具体类型</a>。</p><p>不要从使用 API 导出接口的 <a href=https://abseil.io/resources/swe-book/html/ch13.html#techniques_for_using_test_doubles>test double</a> 实现。相反，应设计可以使用 <a href=https://abseil.io/resources/swe-book/html/ch12.html#test_via_public_apis>实际实现</a> 的<a href=%28https://abseil.io/resources/swe-book/html/ch12.html#test_via_public_apis%29>公共API</a>进行测试。有关详细信息，请参阅 <a href=https://google.github.io/styleguide/go/index.html#gotip>GoTip #42：为测试编写存根</a>。即使在使用实现不可行的情况下，也没有必要引入一个完全覆盖类型所有方法的接口；消费者可以创建一个只包含它需要的方法的接口，如 <a href=https://google.github.io/styleguide/go/index.html#gotip>GoTip #78: Minimal Viable Interfaces</a> 中所示。</p><p>要测试使用 Stubby RPC 客户端的包，请使用真实的客户端连接。如果无法在测试中运行真实服务器，Google 的内部做法是使用内部 rpctest 包（即将推出！）获得与本地 [test double] 的真实客户端连接。</p><p>在使用之前不要定义接口（参见 <a href=https://testing.googleblog.com/2017/08/code-health-eliminate-yagni-smells.html>TotT: Code Health: Eliminate YAGNI Smells</a>）。如果没有实际的使用示例，就很难判断一个接口是否必要，更不用说它应该包含哪些方法了。</p><p>如果不需要传递不同的类型，则不要使用接口类型作为参数。</p><p>不要导出不需要开放的接口。</p><p><strong>TODO:</strong> 写一个关于接口的更深入的文档并在这里链接到它。</p><pre tabindex=0><code>// Good:
package consumer // consumer.go

type Thinger interface { Thing() bool }

func Foo(t Thinger) string { ... }
// Good:
package consumer // consumer_test.go

type fakeThinger struct{ ... }
func (t fakeThinger) Thing() bool { ... }
...
if Foo(fakeThinger{...}) == &#34;x&#34; { ... }
// Bad:
package producer

type Thinger interface { Thing() bool }

type defaultThinger struct{ ... }
func (t defaultThinger) Thing() bool { ... }

func NewThinger() Thinger { return defaultThinger{ ... } }
// Good:
package producer

type Thinger struct{ ... }
func (t Thinger) Thing() bool { ... }

func NewThinger() Thinger { return Thinger{ ... } }
</code></pre><h3 id=泛型>泛型
<a class=anchor href=#%e6%b3%9b%e5%9e%8b>#</a></h3><p>泛型（正式名称为“<a href=https://go.dev/design/43651-type-parameters>类型参数</a>”）在满足业务需求时被允许使用。在许多应用程序中，使用现有传统的（切片、映射、接口等）方式也可以正常工作，而不会增加复杂性，因此请注意不要过早使用。请参阅关于 <a href=https://google.github.io/styleguide/go/guide#least-mechanism>最小机制</a> 的讨论。</p><p>在使用泛型的导出时，请确保对其进行适当的记录。强烈鼓励包含可运行的 <a href=https://google.github.io/styleguide/go/decisions#examples>examples</a>。</p><p>不要仅仅因为你正在实现一个不关心其成员元素类型的算法或数据结构而使用泛型。如果在实践中只有一种类型被实例化，那么首先让您的代码在该类型上工作，而不使用泛型。与删除发现不必要的抽象相比，稍后添加多态性将更简单。</p><p>不要使用泛型来发明领域特定语言 (DSL)。特别是，不要引入可能会给阅读者带来沉重负担的错误处理框架。相反，更应该使用 <a href=https://google.github.io/styleguide/go/decisions#errors>错误处理</a> 做法。对于测试，要特别小心引入 <a href=https://google.github.io/styleguide/go/decisions#assert>断言库</a> 或框架，尤其是很少发现<a href=https://google.github.io/styleguide/go/decisions#useful-test-failures>失败case</a>的。</p><p>一般来说：</p><ul><li><a href="https://www.youtube.com/watch?v=Pa_e9EeCdy8&t=1250s">写代码，不要去设计类型</a>。来自 Robert Griesemer 和 Ian Lance Taylor 的 GopherCon 演讲。</li><li>如果您有几种类型共享一个有用的统一界面，请考虑使用该界面对解决方案进行建模。可能不需要泛型。</li><li>否则，不要依赖 <code>any</code> 类型和过多的 <a href=https://tour.golang.org/methods/16>类型断言</a>，这时应考虑泛型。</li></ul><p>更多也可以参考：</p><ul><li><a href="https://www.youtube.com/watch?v=nr8EpUO9jhw">在 Go 中使用泛型</a>，Ian Lance Taylor 的演讲</li><li>Go 网页上的<a href=https://go.dev/doc/tutorial/generics>泛型教程</a></li></ul><h3 id=参数值传递>参数值传递
<a class=anchor href=#%e5%8f%82%e6%95%b0%e5%80%bc%e4%bc%a0%e9%80%92>#</a></h3><p>不要为了节省几个字节而将指针作为函数参数传递。 如果一个函数在整个过程中只将参数<code>x</code>处理为<code>*x</code>，那么不应该采用指针。 常见的例子包括传递一个指向字符串的指针（<code>*string</code>）或一个指向接口值的指针（<code>*io.Reader</code>）。 在这两种情况下，值本身都是固定大小的，可以直接传递。</p><p>此建议不适用于大型结构体，甚至可能会增加大小的小型结构。 特别是，<code>pb</code>消息通常应该通过指针而不是值来处理。 指针类型满足 <code>proto.Message</code> 接口（被 <code>proto.Marshal</code>、<code>protocmp.Transform</code> 等接受），并且协议缓冲区消息可能非常大，并且随着时间的推移通常会变得更大。</p><h3 id=接收者类型>接收者类型
<a class=anchor href=#%e6%8e%a5%e6%94%b6%e8%80%85%e7%b1%bb%e5%9e%8b>#</a></h3><p><a href=https://golang.org/ref/spec#Method_declarations>方法接收者</a> 和常规函数参数一样，也可以使用值或指针传递。 选择哪个应该基于该方法应该属于哪个[方法集]（https://golang.org/ref/spec#Method_sets）。</p><p><strong>正确性胜过速度或简单性。</strong> 在某些情况下是必须使用指针的。 在其他情况下，如果您对代码的增长方式没有很好的了解，请为大类型选择指针或作为面向未来的指针，并为<a href=%28https://en.wikipedia.org/wiki/Passive_data_structure%29>简单的的数据</a>使用值。</p><p>下面的列表更详细地说明了每个案例：</p><ul><li><p>如果接收者是一个切片并且该方法没有重新切片或重新分配切片，应使用值而不是指针。</p><pre tabindex=0><code>// Good:
type Buffer []byte

func (b Buffer) Len() int { return len(b) }
</code></pre></li><li><p>如果方法需要修改接收者，应使用指针。</p><pre tabindex=0><code>// Good:
type Counter int

func (c *Counter) Inc() { *c++ }

// See https://pkg.go.dev/container/heap.
type Queue []Item

func (q *Queue) Push(x Item) { *q = append([]Item{x}, *q...) }
</code></pre></li><li><p>如果接收者包含 <a href=https://google.github.io/styleguide/go/decisions#copying>不能被安全复制的</a> 字段, 应使用指针接收者。常见的例子是 <a href=https://pkg.go.dev/sync#Mutex><code>sync.Mutex</code></a> 和其他同步类型。</p><pre tabindex=0><code>// Good:
type Counter struct {
    mu    sync.Mutex
    total int
}

func (c *Counter) Inc() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.total++
}
</code></pre><p><strong>提示：</strong> 检查类型的 <a href=https://pkg.go.dev/time#example-Duration>Godoc</a> 以获取有关复制是否安全的信息。</p></li><li><p>如果接收者是“大”结构或数组，则指针接收者可能更有效。 传递结构相当于将其所有字段或元素作为参数传递给方法。 如果这看起来太大而无法<a href=https://google.github.io/styleguide/go/decisions#pass-values>按值传递</a>，那么指针是一个不错的选择。</p></li><li><p>对于将调用修改接收者的其他函数，而这些修改对此方法不可见，请使用值类型； 否则使用指针。</p></li><li><p>如果接收者是一个结构或数组，其元素中的任何一个都是指向可能发生变异的东西的指针，那么更应该指针接收者以使阅读者清楚地了解可变性的意图。</p><pre tabindex=0><code>// Good:
type Counter struct {
    m *Metric
}

func (c *Counter) Inc() {
    c.m.Add(1)
}
</code></pre></li><li><p>如果接收者是<a href=https://pkg.go.dev/builtin>内置类型</a>，例如整数或字符串，不需要修改，使用值。</p><pre tabindex=0><code>// Good:
type User string

func (u User) String() { return string(u) }
</code></pre></li><li><p>接收者是<code>map</code>, <code>function</code> 或 <code>channel</code>，使用值类型，而不是指针。</p><pre tabindex=0><code>// Good:
// See https://pkg.go.dev/net/http#Header.
type Header map[string][]string

func (h Header) Add(key, value string) { /* omitted */ }
</code></pre></li><li><p>如果接收器是一个“小”数组或结构，它自然是一个没有可变字段和指针，那么值接收者通常是正确的选择。</p><pre tabindex=0><code>// Good:
// See https://pkg.go.dev/time#Time.
type Time struct { /* omitted */ }

func (t Time) Add(d Duration) Time { /* omitted */ }
</code></pre></li><li><p>如有疑问，请使用指针接收者。</p></li></ul><p>作为一般准则，最好将类型的方法设为全部指针方法或全部值方法。</p><p><strong>注意：</strong> 关于是否值或指针的函数是否会影响性能，存在很多错误信息。 编译器可以选择将指针传递到堆栈上的值以及复制堆栈上的值，但在大多数情况下，这些考虑不应超过代码的可读性和正确性。 当性能确实很重要时，重要的是在确定一种方法优于另一种方法之前，用一个现实的基准来描述这两种方法。</p><h3 id=switch-和-break><code>switch</code> 和 <code>break</code>
<a class=anchor href=#switch-%e5%92%8c-break>#</a></h3><p>不要在<code>switch</code>子句末尾使用没有目标标签的<code>break</code>语句； 它们是多余的。 与 C 和 Java 不同，Go 中的 <code>switch</code> 子句会自动中断，并且需要 <code>fallthrough</code> 语句来实现 C 风格的行为。 如果您想阐明空子句的目的，请使用注释而不是 <code>break</code>。</p><pre tabindex=0><code>// Good:
switch x {
case &#34;A&#34;, &#34;B&#34;:
    buf.WriteString(x)
case &#34;C&#34;:
    // handled outside of the switch statement
default:
    return fmt.Errorf(&#34;unknown value: %q&#34;, x)
}
// Bad:
switch x {
case &#34;A&#34;, &#34;B&#34;:
    buf.WriteString(x)
    break // this break is redundant
case &#34;C&#34;:
    break // this break is redundant
default:
    return fmt.Errorf(&#34;unknown value: %q&#34;, x)
}
</code></pre><blockquote><p><strong>Note:</strong> If a <code>switch</code> clause is within a <code>for</code> loop, using <code>break</code> within <code>switch</code> does not exit the enclosing <code>for</code> loop.</p><pre tabindex=0><code>for {
  switch x {
  case &#34;A&#34;:
     break // exits the switch, not the loop
  }
}
</code></pre><p>To escape the enclosing loop, use a label on the <code>for</code> statement:</p><pre tabindex=0><code>loop:
  for {
    switch x {
    case &#34;A&#34;:
       break loop // exits the loop
    }
  }
</code></pre></blockquote><h3 id=同步函数>同步函数
<a class=anchor href=#%e5%90%8c%e6%ad%a5%e5%87%bd%e6%95%b0>#</a></h3><p>同步函数直接返回它们的结果，并在返回之前完成所有回调或通道操作。 首选同步函数而不是异步函数。</p><p>同步函数使 goroutine 在调用中保持本地化。 这有助于推理它们的生命周期，并避免泄漏和数据竞争。 同步函数也更容易测试，因为调用者可以传递输入并检查输出，而无需轮询或同步。</p><p>如有必要，调用者可以通过在单独的 goroutine 中调用函数来添加并发性。 然而，在调用方移除不必要的并发是相当困难的（有时是不可能的）。</p><p>也可以看看：</p><ul><li>“重新思考经典并发模式”，Bryan Mills 的演讲：<a href=https://drive.google.com/file/d/1nPdvhB0PutEJzdCq5ms6UI58dp50fcAN/view>幻灯片</a>，[视频](<a href=https://www.youtube.com/>https://www.youtube.com/</a> 看？v=5zXAHh5tJqQ)</li></ul><h3 id=类型别名>类型别名
<a class=anchor href=#%e7%b1%bb%e5%9e%8b%e5%88%ab%e5%90%8d>#</a></h3><p>使用<em>类型定义</em>，<code>type T1 T2</code>，定义一个新类型。
使用 <a href=http://golang.org/ref/spec#Type_declarations><em>类型别名</em></a>, <code>type T1 = T2</code> 来引用现有类型而不定义新类型。
类型别名很少见； 它们的主要用途是帮助将包迁移到新的源代码位置。 不要在不需要时使用类型别名。</p><h3 id=使用-q>使用 %q
<a class=anchor href=#%e4%bd%bf%e7%94%a8-q>#</a></h3><p>Go 的格式函数（<code>fmt.Printf</code> 等）有一个 <code>%q</code> 动词，它在双引号内打印字符串。</p><pre tabindex=0><code>// Good:
fmt.Printf(&#34;value %q looks like English text&#34;, someText)
</code></pre><p>更应该使用 <code>%q</code> 而不是使用 <code>%s</code> 手动执行等效操作：</p><pre tabindex=0><code>// Bad:
fmt.Printf(&#34;value \&#34;%s\&#34; looks like English text&#34;, someText)
// Avoid manually wrapping strings with single-quotes too:
fmt.Printf(&#34;value &#39;%s&#39; looks like English text&#34;, someText)
</code></pre><p>建议在供人使用的输出中使用 <code>%q</code>，其输入值可能为空或包含控制字符。 可能很难注意到一个无声的空字符串，但是 <code>""</code> 就这样清楚地突出了。</p><h3 id=使用-any>使用 any
<a class=anchor href=#%e4%bd%bf%e7%94%a8-any>#</a></h3><p>Go 1.18 将 <code>any</code> 类型作为 <a href=https://go.googlesource.com/proposal/+/master/design/18130-type-alias.md>别名</a> 引入到 <code>interface{}</code>。 因为它是一个别名，所以 <code>any</code> 在许多情况下等同于 <code>interface{}</code>，而在其他情况下，它可以通过显式转换轻松互换。 在新代码中应使用 <code>any</code>。</p><h2 id=通用库>通用库
<a class=anchor href=#%e9%80%9a%e7%94%a8%e5%ba%93>#</a></h2><h3 id=flags>Flags
<a class=anchor href=#flags>#</a></h3><p>Google 代码库中的 Go 程序使用 <a href=https://golang.org/pkg/flag/>标准 <code>flag</code> 包</a> 的内部变体。 它具有类似的接口，但与 Google 内部系统的互操作性很好。 Go 二进制文件中的标志名称应该更应该使用下划线来分隔单词，尽管包含标志值的变量应该遵循标准的 Go 名称样式（<a href=https://google.github.io/styleguide/go/guide#mixed-caps>混合大写字母</a>）。 具体来说，标志名称应该是蛇大小写，变量名称应该是骆驼大小写。</p><pre tabindex=0><code>// Good:
var (
    pollInterval = flag.Duration(&#34;poll_interval&#34;, time.Minute, &#34;Interval to use for polling.&#34;)
)
// Bad:
var (
    poll_interval = flag.Int(&#34;pollIntervalSeconds&#34;, 60, &#34;Interval to use for polling in seconds.&#34;)
)
</code></pre><p>Flags只能在 <code>package main</code> 或等效项中定义。</p><p>通用包应该使用 Go API 进行配置，而不是通过命令行界面进行配置；不要让导入库导出新标志作为副作用。也就是说，更倾向于显式的函数参数或结构字段分配，或者低频和严格审查的全局变量导出。在需要打破此规则的极少数情况下，标志名称必须清楚地表明它配置的包。</p><p>如果您的标志是全局变量，在导入部分之后，将它们放在 <code>var</code> 组中。</p><p>关于使用子命令创建 <a href=https://google.github.io/styleguide/go/best-practices#complex-clis>complex CLI</a> 的最佳实践还有其他讨论。</p><p>也可以看看：</p><ul><li><a href=https://abseil.io/tips/45>本周提示 #45：避免标记，尤其是在库代码中</a></li><li><a href=https://google.github.io/styleguide/go/index.html#gotip>Go Tip #10：配置结构和标志</a></li><li><a href=https://google.github.io/styleguide/go/index.html#gotip>Go Tip #80：依赖注入原则</a></li></ul><h3 id=日志>日志
<a class=anchor href=#%e6%97%a5%e5%bf%97>#</a></h3><p>Google 代码库中的 Go 程序使用 <a href=https://pkg.go.dev/log>标准 <code>log</code> 包</a> 的变体。它具有类似但功能更强大的interface，并且可以与 Google 内部系统进行良好的互操作。该库的开源版本可通过 <a href=https://pkg.go.dev/github.com/golang/glog>package <code>glog</code></a> 获得，开源 Google 项目可能会使用它，但本指南指的是它始终作为“日志”。</p><p><strong>注意：</strong> 对于异常的程序退出，这个库使用 <code>log.Fatal</code> 通过堆栈跟踪中止，使用 <code>log.Exit</code> 在没有堆栈跟踪的情况下停止。标准库中没有 <code>log.Panic</code> 函数。</p><p><strong>提示：</strong> <code>log.Info(v)</code> 等价于 <code>log.Infof("%v", v)</code>，其他日志级别也是如此。当您没有格式化要做时，首选非格式化版本。</p><p>也可以看看：</p><ul><li><a href=https://google.github.io/styleguide/go/best-practices#error-logging>记录错误</a> 和 <a href=https://google.github.io/styleguide/go/best-practices#vlog>自定义详细日志级别</a></li><li>何时以及如何使用日志包<a href=https://google.github.io/styleguide/go/best-practices#checks-and-panics>停止程序</a></li></ul><h3 id=上下文>上下文
<a class=anchor href=#%e4%b8%8a%e4%b8%8b%e6%96%87>#</a></h3><p><a href=https://pkg.go.dev/context><code>context.Context</code></a> 类型的值携带跨 API 和进程边界的安全凭证、跟踪信息、截止日期和取消信号。 与 Google 代码库中使用线程本地存储的 C++ 和 Java 不同，Go 程序在整个函数调用链中显式地传递上下文，从传入的 RPC 和 HTTP 请求到传出请求。</p><p>当传递给函数或方法时，<code>context.Context</code> 始终是第一个参数。</p><pre tabindex=0><code>func F(ctx context.Context /* other arguments */) {}
</code></pre><p>例外情况是：</p><ul><li><p>在 HTTP 处理程序中，上下文来自 <a href=https://pkg.go.dev/net/http#Request.Context><code>req.Context()</code></a>。</p></li><li><p>在流式 RPC 方法中，上下文来自流。</p><p>使用 gRPC 流的代码从生成的服务器类型中的 <code>Context()</code> 方法访问上下文，该方法实现了 <code>grpc.ServerStream</code>。请参阅 <a href=https://grpc.io/docs/languages/go/generated-code/>https://grpc.io/docs/languages/go/generated-code/</a>。</p></li><li><p>在入口函数（此类函数的示例见下文）中，使用 <a href=https://pkg.go.dev/context/#Background><code>context.Background()</code></a>。</p><ul><li>在二进制目标中：<code>main</code></li><li>在通用代码和库中：<code>init</code></li><li>在测试中：<code>TestXXX</code>、<code>BenchmarkXXX</code>、<code>FuzzXXX</code></li></ul></li></ul><blockquote><p><strong>注意</strong>：调用链中间的代码很少需要使用 <code>context.Background()</code> 创建自己的基本上下文。更应该从调用者那里获取上下文，除非它是错误的上下文。</p><p>您可能会遇到服务器库（在 Google 的 Go 服务器框架中实现 Stubby、gRPC 或 HTTP），它们为每个请求构建一个新的上下文对象。这些上下文立即填充来自传入请求的信息，因此当传递给请求处理程序时，上下文的附加值已从客户端调用者通过网络边界传播给它。此外，这些上下文的生命周期仅限于请求的生命周期：当请求完成时，上下文将被取消。</p><p>除非你正在实现一个服务器框架，否则你不应该在库代码中使用 <code>context.Background()</code> 创建上下文。相反，如果有可用的现有上下文，则更应该使用下面提到的上下文分离。如果您认为在入口点函数之外确实需要<code>context.Background()</code>，请在提交实现之前与 Google Go 风格的邮件列表讨论它。</p></blockquote><p><code>context.Context</code> 在函数中首先出现的约定也适用于测试助手。</p><pre tabindex=0><code>// Good:
func readTestFile(ctx context.Context, t *testing.T, path string) string {}
</code></pre><p>不要将上下文成员添加到结构类型。 相反，为需要传递它的类型的每个方法添加一个上下文参数。 一个例外是其签名必须与标准库或 Google 无法控制的第三方库中的接口匹配的方法。 这种情况非常罕见，应该在实施和可读性审查之前与 Google Go 风格的邮件列表讨论。</p><p>Google 代码库中必须产生可以在取消父上下文后运行的后台操作的代码可以使用内部包进行分离。 关注 <a href=https://github.com/golang/go/issues/40221>https://github.com/golang/go/issues/40221</a> 讨论开源替代方案。</p><p>由于上下文是不可变的，因此可以将相同的上下文传递给共享相同截止日期、取消信号、凭据、父跟踪等的多个调用。</p><p>更多参见：</p><ul><li><a href=https://go.dev/blog/context-and-structs>上下文和结构</a></li></ul><h4 id=自定义上下文>自定义上下文
<a class=anchor href=#%e8%87%aa%e5%ae%9a%e4%b9%89%e4%b8%8a%e4%b8%8b%e6%96%87>#</a></h4><p>不要在函数签名中创建自定义上下文类型或使用上下文以外的接口。 这条规定没有例外。</p><p>想象一下，如果每个团队都有一个自定义上下文。 对于包 P 和 Q 的所有对，从包 P 到包 Q 的每个函数调用都必须确定如何将“PContext”转换为“QContext”。这对人类来说是不切实际且容易出错的，并且它会进行自动重构 添加上下文参数几乎是不可能的。</p><p>如果您要传递应用程序数据，请将其放入参数、接收器、全局变量中，或者如果它确实属于那里，则放入 Context 值中。 创建自己的 Context 类型是不可接受的，因为它破坏了 Go 团队使 Go 程序在生产中正常工作的能力。</p><h3 id=cryptorand>crypto/rand
<a class=anchor href=#cryptorand>#</a></h3><p>不要使用包 <code>math/rand</code> 来生成密钥，即使是一次性的。 如果未生成随机种子，则生成器是完全可预测的。 用<code>time.Nanoseconds()</code>生成种子，也只有几位熵。 相反，请使用 <code>crypto/rand</code> ，如果需要文本，请打印为十六进制或 base64。</p><pre tabindex=0><code>// Good:
import (
    &#34;crypto/rand&#34;
    // &#34;encoding/base64&#34;
    // &#34;encoding/hex&#34;
    &#34;fmt&#34;

    // ...
)

func Key() string {
    buf := make([]byte, 16)
    if _, err := rand.Read(buf); err != nil {
        log.Fatalf(&#34;Out of randomness, should never happen: %v&#34;, err)
    }
    return fmt.Sprintf(&#34;%x&#34;, buf)
    // or hex.EncodeToString(buf)
    // or base64.StdEncoding.EncodeToString(buf)
}
</code></pre><h2 id=有用的测试失败>有用的测试失败
<a class=anchor href=#%e6%9c%89%e7%94%a8%e7%9a%84%e6%b5%8b%e8%af%95%e5%a4%b1%e8%b4%a5>#</a></h2><p>应该可以在不读取测试源的情况下诊断测试失败。 测试应该失败并显示有用的消息详细说明：</p><ul><li>是什么导致了失败</li><li>哪些输入导致错误</li><li>实际结果</li><li>预期的结果</li></ul><p>下面概述了实现这一目标的具体约定。</p><h3 id=断言库>断言库
<a class=anchor href=#%e6%96%ad%e8%a8%80%e5%ba%93>#</a></h3><p>不要创建“断言库”作为测试的助手。</p><p>断言库是试图在测试中结合验证和生成失败消息的库（尽管同样的陷阱也可能适用于其他测试助手）。 有关测试助手和断言库之间区别的更多信息，请参阅 <a href=https://google.github.io/styleguide/go/best-practices#test-functions>最佳实践</a>。</p><pre tabindex=0><code>// Bad:
var obj BlogPost

assert.IsNotNil(t, &#34;obj&#34;, obj)
assert.StringEq(t, &#34;obj.Type&#34;, obj.Type, &#34;blogPost&#34;)
assert.IntEq(t, &#34;obj.Comments&#34;, obj.Comments, 2)
assert.StringNotEq(t, &#34;obj.Body&#34;, obj.Body, &#34;&#34;)
</code></pre><p>断言库倾向于提前停止测试（如果 <code>assert</code> 调用 <code>t.Fatalf</code> 或 <code>panic</code>）或省略有关测试正确的相关信息：</p><pre tabindex=0><code>// Bad:
package assert

func IsNotNil(t *testing.T, name string, val interface{}) {
    if val == nil {
        t.Fatalf(&#34;data %s = nil, want not nil&#34;, name)
    }
}

func StringEq(t *testing.T, name, got, want string) {
    if got != want {
        t.Fatalf(&#34;data %s = %q, want %q&#34;, name, got, want)
    }
}
</code></pre><p>复杂的断言函数通常不提供 <a href=https://google.github.io/styleguide/go/decisions#useful-test-failures>有用的失败消息</a> 和存在于测试函数中的上下文。 太多的断言函数和库会导致开发人员体验支离破碎：我应该使用哪个断言库，它应该发出什么样的输出格式，等等？ 碎片化会产生不必要的混乱，特别是对于负责修复潜在下游破坏的库维护者和大规模更改的作者。 与其创建用于测试的特定领域语言，不如使用 Go 本身。</p><p>断言库通常会排除比较和相等检查。 更应该使用标准库，例如 <a href=https://pkg.go.dev/github.com/google/go-cmp/cmp><code>cmp</code></a> 和 <a href=https://golang.org/pkg/fmt/><code>fmt</code></a> 修改为：</p><pre tabindex=0><code>// Good:
var got BlogPost

want := BlogPost{
    Comments: 2,
    Body:     &#34;Hello, world!&#34;,
}

if !cmp.Equal(got, want) {
    t.Errorf(&#34;blog post = %v, want = %v&#34;, got, want)
}
</code></pre><p>对于更多特定于域的比较助手，更应该返回一个可以在测试失败消息中使用的值或错误，而不是传递 <code>*testing.T</code> 并调用其错误报告方法：</p><pre tabindex=0><code>// Good:
func postLength(p BlogPost) int { return len(p.Body) }

func TestBlogPost_VeritableRant(t *testing.T) {
    post := BlogPost{Body: &#34;I am Gunnery Sergeant Hartman, your senior drill instructor.&#34;}

    if got, want := postLength(post), 60; got != want {
        t.Errorf(&#34;length of post = %v, want %v&#34;, got, want)
    }
}
</code></pre><p><strong>最佳实践：</strong> 如果 <code>postLength</code> 很重要，直接测试它是有意义的，独立于使用它的任何测试。</p><p>也可以看看：</p><ul><li><a href=https://google.github.io/styleguide/go/decisions#types-of-equality>平等比较和差异</a></li><li><a href=https://google.github.io/styleguide/go/decisions#print-diffs>打印差异</a></li><li>有关测试助手和断言助手之间区别的更多信息，请参阅<a href=https://google.github.io/styleguide/go/best-practices#test-functions>最佳实践</a></li></ul><h3 id=标识出方法>标识出方法
<a class=anchor href=#%e6%a0%87%e8%af%86%e5%87%ba%e6%96%b9%e6%b3%95>#</a></h3><p>在大多数测试中，失败消息应该包括失败的函数的名称，即使从测试函数的名称中看起来很明显。 具体来说，你的失败信息应该是 <code>YourFunc(%v) = %v, want %v</code> 而不仅仅是 <code>got %v, want %v</code>。</p><h3 id=标识出输入>标识出输入
<a class=anchor href=#%e6%a0%87%e8%af%86%e5%87%ba%e8%be%93%e5%85%a5>#</a></h3><p>在大多数测试中，失败消息应该包括功能输入（如果它们很短）。 如果输入的相关属性不明显（例如，因为输入很大或不透明），您应该使用对正在测试的内容的描述来命名测试用例，并将描述作为错误消息的一部分打印出来。</p><h3 id=got-before-want>Got before want
<a class=anchor href=#got-before-want>#</a></h3><p>测试输出应包括函数在打印预期值之前返回的实际值。 打印测试输出的标准格式是 <code>YourFunc(%v) = %v, want %v</code>。 在你会写“实际”和“预期”的地方，更应该分别使用“得到”和“想要”这两个词。</p><p>对于差异，方向性不太明显，因此包含一个有助于解释失败的关键是很重要的。 请参阅 <a href=https://google.github.io/styleguide/go/decisions#print-diffs>关于打印差异的部分</a>。 无论您在失败消息中使用哪种 diff 顺序，都应将其明确指示为失败消息的一部分，因为现有代码的顺序不一致。</p><h3 id=全结构比较>全结构比较
<a class=anchor href=#%e5%85%a8%e7%bb%93%e6%9e%84%e6%af%94%e8%be%83>#</a></h3><p>如果您的函数返回一个结构体（或任何具有多个字段的数据类型，例如切片、数组和映射），请避免编写执行手动编码的结构体逐个字段比较的测试代码。相反，构建期望函数返回的数据，并使用 <a href=https://google.github.io/styleguide/go/decisions#types-of-equality>深度比较</a> 直接进行比较。</p><p><strong>注意：</strong> 如果您的数据包含模糊测试意图的不相关字段，则这不适用。</p><p>如果您的结构需要比较近似（或等效类型的语义）相等，或者它包含无法比较相等的字段（例如，如果其中一个字段是 <code>io.Reader</code>），请调整 <a href=https://pkg.go.dev/github.com/google/go-cmp/cmp/cmp#Diff><code>cmp. Diff</code></a> 或 <a href=https://pkg.go.dev/github.com/google/go-cmp/cmp/cmp#Equal><code>cmp.Equal</code></a> 与 <a href=https://pkg.go.dev/github.com/google/go-cmp/cmp/cmpopts><code>cmpopts</code></a> 选项比较，例如<a href=https://pkg.go.dev/github.com/google/go-cmp/cmp/cmpopts#IgnoreInterfaces><code>cmpopts.IgnoreInterfaces</code></a> 可能满足您的需求（<a href=https://play.golang.org/p/vrCUNVfxsvF>示例</a>)。</p><p>如果您的函数返回多个返回值，则无需在比较它们之前将它们包装在结构中。只需单独比较返回值并打印它们。</p><pre tabindex=0><code>// Good:
val, multi, tail, err := strconv.UnquoteChar(`\&#34;Fran &amp; Freddie&#39;s Diner\&#34;`, &#39;&#34;&#39;)
if err != nil {
  t.Fatalf(...)
}
if val != `&#34;` {
  t.Errorf(...)
}
if multi {
  t.Errorf(...)
}
if tail != `Fran &amp; Freddie&#39;s Diner&#34;` {
  t.Errorf(...)
}
</code></pre><h3 id=compare-stable-results>Compare stable results
<a class=anchor href=#compare-stable-results>#</a></h3><p>Avoid comparing results that may depend on output stability of a package that you do not own. Instead, the test should compare on semantically relevant information that is stable and resistant to changes in dependencies. For functionality that returns a formatted string or serialized bytes, it is generally not safe to assume that the output is stable.</p><p>For example, <a href=https://golang.org/pkg/encoding/json/#Marshal><code>json.Marshal</code></a> can change (and has changed in the past) the specific bytes that it emits. Tests that perform string equality on the JSON string may break if the <code>json</code> package changes how it serializes the bytes. Instead, a more robust test would parse the contents of the JSON string and ensure that it is semantically equivalent to some expected data structure.</p><h3 id=keep-going>Keep going
<a class=anchor href=#keep-going>#</a></h3><p>Tests should keep going for as long as possible, even after a failure, in order to print out all of the failed checks in a single run. This way, a developer who is fixing the failing test doesn’t have to re-run the test after fixing each bug to find the next bug.</p><p>Prefer calling <code>t.Error</code> over <code>t.Fatal</code> for reporting a mismatch. When comparing several different properties of a function’s output, use <code>t.Error</code> for each of those comparisons.</p><p>Calling <code>t.Fatal</code> is primarily useful for reporting an unexpected error condition, when subsequent comparison failures are not going to be meaningful.</p><p>For table-driven test, consider using subtests and use <code>t.Fatal</code> rather than <code>t.Error</code> and <code>continue</code>. See also <a href=https://google.github.io/styleguide/go/index.html#gotip>GoTip #25: Subtests: Making Your Tests Lean</a>.</p><p><strong>Best practice:</strong> For more discussion about when <code>t.Fatal</code> should be used, see <a href=https://google.github.io/styleguide/go/best-practices#t-fatal>best practices</a>.</p><h3 id=equality-comparison-and-diffs>Equality comparison and diffs
<a class=anchor href=#equality-comparison-and-diffs>#</a></h3><p>The <code>==</code> operator evaluates equality using <a href=http://golang.org/ref/spec#Comparison_operators>language-defined comparisons</a>. Scalar values (numbers, booleans, etc) are compared based on their values, but only some structs and interfaces can be compared in this way. Pointers are compared based on whether they point to the same variable, rather than based on the equality of the values to which they point.</p><p>The <a href=https://pkg.go.dev/github.com/google/go-cmp/cmp><code>cmp</code></a> package can compare more complex data structures not appropriately handled by <code>==</code>, such as slices. Use <a href=https://pkg.go.dev/github.com/google/go-cmp/cmp/cmp#Equal><code>cmp.Equal</code></a> for equality comparison and <a href=https://pkg.go.dev/github.com/google/go-cmp/cmp/cmp#Diff><code>cmp.Diff</code></a> to obtain a human-readable diff between objects.</p><pre tabindex=0><code>// Good:
want := &amp;Doc{
    Type:     &#34;blogPost&#34;,
    Comments: 2,
    Body:     &#34;This is the post body.&#34;,
    Authors:  []string{&#34;isaac&#34;, &#34;albert&#34;, &#34;emmy&#34;},
}
if !cmp.Equal(got, want) {
    t.Errorf(&#34;AddPost() = %+v, want %+v&#34;, got, want)
}
</code></pre><p>As a general-purpose comparison library, <code>cmp</code> may not know how to compare certain types. For example, it can only compare protocol buffer messages if passed the <a href=https://pkg.go.dev/google.golang.org/protobuf/testing/protocmp#Transform><code>protocmp.Transform</code></a> option.</p><pre tabindex=0><code>// Good:
if diff := cmp.Diff(want, got, protocmp.Transform()); diff != &#34;&#34; {
    t.Errorf(&#34;Foo() returned unexpected difference in protobuf messages (-want +got):\n%s&#34;, diff)
}
</code></pre><p>Although the <code>cmp</code> package is not part of the Go standard library, it is maintained by the Go team and should produce stable equality results over time. It is user-configurable and should serve most comparison needs.</p><p>Existing code may make use of the following older libraries, and may continue using them for consistency:</p><ul><li><a href=https://pkg.go.dev/github.com/kylelemons/godebug/pretty><code>pretty</code></a> produces aesthetically pleasing difference reports. However, it quite deliberately considers values that have the same visual representation as equal. In particular, <code>pretty</code> does not catch differences between nil slices and empty ones, is not sensitive to different interface implementations with identical fields, and it is possible to use a nested map as the basis for comparison with a struct value. It also serializes the entire value into a string before producing a diff, and as such is not a good choice for comparing large values. By default, it compares unexported fields, which makes it sensitive to changes in implementation details in your dependencies. For this reason, it is not appropriate to use <code>pretty</code> on protobuf messages.</li></ul><p>Prefer using <code>cmp</code> for new code, and it is worth considering updating older code to use <code>cmp</code> where and when it is practical to do so.</p><p>Older code may use the standard library <code>reflect.DeepEqual</code> function to compare complex structures. <code>reflect.DeepEqual</code> should not be used for checking equality, as it is sensitive to changes in unexported fields and other implementation details. Code that is using <code>reflect.DeepEqual</code> should be updated to one of the above libraries.</p><p><strong>Note:</strong> The <code>cmp</code> package is designed for testing, rather than production use. As such, it may panic when it suspects that a comparison is performed incorrectly to provide instruction to users on how to improve the test to be less brittle. Given cmp’s propensity towards panicking, it makes it unsuitable for code that is used in production as a spurious panic may be fatal.</p><h3 id=level-of-detail>Level of detail
<a class=anchor href=#level-of-detail>#</a></h3><p>The conventional failure message, which is suitable for most Go tests, is <code>YourFunc(%v) = %v, want %v</code>. However, there are cases that may call for more or less detail:</p><ul><li>Tests performing complex interactions should describe the interactions too. For example, if the same <code>YourFunc</code> is called several times, identify which call failed the test. If it’s important to know any extra state of the system, include that in the failure output (or at least in the logs).</li><li>If the data is a complex struct with significant boilerplate, it is acceptable to describe only the important parts in the message, but do not overly obscure the data.</li><li>Setup failures do not require the same level of detail. If a test helper populates a Spanner table but Spanner was down, you probably don’t need to include which test input you were going to store in the database. <code>t.Fatalf("Setup: Failed to set up test database: %s", err)</code> is usually helpful enough to resolve the issue.</li></ul><p><strong>Tip:</strong> Make your failure mode trigger during development. Review what the failure message looks like and whether a maintainer can effectively deal with the failure.</p><p>There are some techniques for reproducing test inputs and outputs clearly:</p><ul><li>When printing string data, <a href=https://google.github.io/styleguide/go/decisions#use-percent-q><code>%q</code> is often useful</a> to emphasize that the value is important and to more easily spot bad values.</li><li>When printing (small) structs, <code>%+v</code> can be more useful than <code>%v</code>.</li><li>When validation of larger values fails, <a href=https://google.github.io/styleguide/go/decisions#print-diffs>printing a diff</a> can make it easier to understand the failure.</li></ul><h3 id=print-diffs>Print diffs
<a class=anchor href=#print-diffs>#</a></h3><p>If your function returns large output then it can be hard for someone reading the failure message to find the differences when your test fails. Instead of printing both the returned value and the wanted value, make a diff.</p><p>To compute diffs for such values, <code>cmp.Diff</code> is preferred, particularly for new tests and new code, but other tools may be used. See <a href=https://google.github.io/styleguide/go/decisions#types-of-equality>types of equality</a> for guidance regarding the strengths and weaknesses of each function.</p><ul><li><a href=https://pkg.go.dev/github.com/google/go-cmp/cmp/cmp#Diff><code>cmp.Diff</code></a></li><li><a href=https://pkg.go.dev/github.com/kylelemons/godebug/pretty#Compare><code>pretty.Compare</code></a></li></ul><p>You can use the <a href=https://pkg.go.dev/github.com/kylelemons/godebug/diff><code>diff</code></a> package to compare multi-line strings or lists of strings. You can use this as a building block for other kinds of diffs.</p><p>Add some text to your failure message explaining the direction of the diff.</p><ul><li>Something like <code>diff (-want +got)</code> is good when you’re using the <code>cmp</code>, <code>pretty</code>, and <code>diff</code> packages (if you pass <code>(want, got)</code> to the function), because the <code>-</code> and <code>+</code> that you add to your format string will match the <code>-</code> and <code>+</code> that actually appear at the beginning of the diff lines. If you pass <code>(got, want)</code> to your function, the correct key would be <code>(-got +want)</code> instead.</li><li>The <code>messagediff</code> package uses a different output format, so the message <code>diff (want -> got)</code> is appropriate when you’re using it (if you pass <code>(want, got)</code> to the function), because the direction of the arrow will match the direction of the arrow in the “modified” lines.</li></ul><p>The diff will span multiple lines, so you should print a newline before you print the diff.</p><h3 id=test-error-semantics>Test error semantics
<a class=anchor href=#test-error-semantics>#</a></h3><p>When a unit test performs string comparisons or uses a vanilla <code>cmp</code> to check that particular kinds of errors are returned for particular inputs, you may find that your tests are brittle if any of those error messages are reworded in the future. Since this has the potential to turn your unit test into a change detector (see <a href=https://testing.googleblog.com/2015/01/testing-on-toilet-change-detector-tests.html>TotT: Change-Detector Tests Considered Harmful</a> ), don’t use string comparison to check what type of error your function returns. However, it is permissible to use string comparisons to check that error messages coming from the package under test satisfy certain properties, for example, that it includes the parameter name.</p><p>Error values in Go typically have a component intended for human eyes and a component intended for semantic control flow. Tests should seek to only test semantic information that can be reliably observed, rather than display information that is intended for human debugging, as this is often subject to future changes. For guidance on constructing errors with semantic meaning see <a href=https://google.github.io/styleguide/go/best-practices#error-handling>best-practices regarding errors</a>. If an error with insufficient semantic information is coming from a dependency outside your control, consider filing a bug against the owner to help improve the API, rather than relying on parsing the error message.</p><p>Within unit tests, it is common to only care whether an error occurred or not. If so, then it is sufficient to only test whether the error was non-nil when you expected an error. If you would like to test that the error semantically matches some other error, then consider using <code>cmp</code> with <a href=https://pkg.go.dev/github.com/google/go-cmp/cmp/cmpopts#EquateErrors><code>cmpopts.EquateErrors</code></a>.</p><blockquote><p><strong>Note:</strong> If a test uses <a href=https://pkg.go.dev/github.com/google/go-cmp/cmp/cmpopts#EquateErrors><code>cmpopts.EquateErrors</code></a> but all of its <code>wantErr</code> values are either <code>nil</code> or <code>cmpopts.AnyError</code>, then using <code>cmp</code> is <a href=https://google.github.io/styleguide/go/guide#least-mechanism>unnecessary mechanism</a>. Simplify the code by making the want field a <code>bool</code>. You can then use a simple comparison with <code>!=</code>.</p><pre tabindex=0><code>// Good:
gotErr := f(test.input) != nil
if gotErr != test.wantErr {
    t.Errorf(&#34;f(%q) returned err = %v, want error presence = %v&#34;, test.input, gotErr, test.wantErr)
}
</code></pre></blockquote><p>See also <a href=https://google.github.io/styleguide/go/index.html#gotip>GoTip #13: Designing Errors for Checking</a>.</p><h2 id=test-structure>Test structure
<a class=anchor href=#test-structure>#</a></h2><h3 id=subtests>Subtests
<a class=anchor href=#subtests>#</a></h3><p>The standard Go testing library offers a facility to <a href=https://pkg.go.dev/testing#hdr-Subtests_and_Sub_benchmarks>define subtests</a>. This allows flexibility in setup and cleanup, controlling parallelism, and test filtering. Subtests can be useful (particularly for table-driven tests), but using them is not mandatory. See also <a href=https://blog.golang.org/subtests>https://blog.golang.org/subtests</a>.</p><p>Subtests should not depend on the execution of other cases for success or initial state, because subtests are expected to be able to be run individually with using <code>go test -run</code> flags or with Bazel <a href=https://bazel.build/docs/user-manual#test-filter>test filter</a> expressions.</p><h4 id=subtest-names>Subtest names
<a class=anchor href=#subtest-names>#</a></h4><p>Name your subtest such that it is readable in test output and useful on the command line for users of test filtering. When you use <code>t.Run</code> to create a subtest, the first argument is used as a descriptive name for the test. To ensure that test results are legible to humans reading the logs, choose subtest names that will remain useful and readable after escaping. Think of subtest names more like a function identifier than a prose description. The test runner replaces spaces with underscores, and escapes non-printing characters. If your test data benefits from a longer description, consider putting the description in a separate field (perhaps to be printed using <code>t.Log</code> or alongside failure messages).</p><p>Subtests may be run individually using flags to the <a href=https://golang.org/cmd/go/#hdr-Testing_flags>Go test runner</a> or Bazel <a href=https://bazel.build/docs/user-manual#test-filter>test filter</a>, so choose descriptive names that are also easy to type.</p><blockquote><p><strong>Warning:</strong> Slash characters are particularly unfriendly in subtest names, since they have [special meaning for test filters](<a href="https://blog.golang.org/subtests#:~:text=Perhaps">https://blog.golang.org/subtests#:~:text=Perhaps</a> a bit,match any tests).</p><blockquote><pre tabindex=0><code># Bad:
# Assuming TestTime and t.Run(&#34;America/New_York&#34;, ...)
bazel test :mytest --test_filter=&#34;Time/New_York&#34;    # Runs nothing!
bazel test :mytest --test_filter=&#34;Time//New_York&#34;   # Correct, but awkward.
</code></pre></blockquote></blockquote><p>To <a href=https://google.github.io/styleguide/go/decisions#identify-the-input>identify the inputs</a> of the function, include them in the test’s failure messages, where they won’t be escaped by the test runner.</p><pre tabindex=0><code>// Good:
func TestTranslate(t *testing.T) {
    data := []struct {
        name, desc, srcLang, dstLang, srcText, wantDstText string
    }{
        {
            name:        &#34;hu=en_bug-1234&#34;,
            desc:        &#34;regression test following bug 1234. contact: cleese&#34;,
            srcLang:     &#34;hu&#34;,
            srcText:     &#34;cigarettát és egy öngyújtót kérek&#34;,
            dstLang:     &#34;en&#34;,
            wantDstText: &#34;cigarettes and a lighter please&#34;,
        }, // ...
    }
    for _, d := range data {
        t.Run(d.name, func(t *testing.T) {
            got := Translate(d.srcLang, d.dstLang, d.srcText)
            if got != d.wantDstText {
                t.Errorf(&#34;%s\nTranslate(%q, %q, %q) = %q, want %q&#34;,
                    d.desc, d.srcLang, d.dstLang, d.srcText, got, d.wantDstText)
            }
        })
    }
}
</code></pre><p>Here are a few examples of things to avoid:</p><pre tabindex=0><code>// Bad:
// Too wordy.
t.Run(&#34;check that there is no mention of scratched records or hovercrafts&#34;, ...)
// Slashes cause problems on the command line.
t.Run(&#34;AM/PM confusion&#34;, ...)
</code></pre><h3 id=table-driven-tests>Table-driven tests
<a class=anchor href=#table-driven-tests>#</a></h3><p>Use table-driven tests when many different test cases can be tested using similar testing logic.</p><ul><li>When testing whether the actual output of a function is equal to the expected output. For example, the many <a href=https://cs.opensource.google/go/go/+/master:src/fmt/fmt_test.go>tests of <code>fmt.Sprintf</code></a> or the minimal snippet below.</li><li>When testing whether the outputs of a function always conform to the same set of invariants. For example, <a href="https://cs.opensource.google/go/go/+/master:src/net/dial_test.go;l=318;drc=5b606a9d2b7649532fe25794fa6b99bd24e7697c">tests for <code>net.Dial</code></a>.</li></ul><p>Here is the minimal structure of a table-driven test, copied from the standard <code>strings</code> library. If needed, you may use different names, move the test slice into the test function, or add extra facilities such as subtests or setup and cleanup functions. Always keep <a href=https://google.github.io/styleguide/go/decisions#useful-test-failures>useful test failures</a> in mind.</p><pre tabindex=0><code>// Good:
var compareTests = []struct {
    a, b string
    i    int
}{
    {&#34;&#34;, &#34;&#34;, 0},
    {&#34;a&#34;, &#34;&#34;, 1},
    {&#34;&#34;, &#34;a&#34;, -1},
    {&#34;abc&#34;, &#34;abc&#34;, 0},
    {&#34;ab&#34;, &#34;abc&#34;, -1},
    {&#34;abc&#34;, &#34;ab&#34;, 1},
    {&#34;x&#34;, &#34;ab&#34;, 1},
    {&#34;ab&#34;, &#34;x&#34;, -1},
    {&#34;x&#34;, &#34;a&#34;, 1},
    {&#34;b&#34;, &#34;x&#34;, -1},
    // test runtime·memeq&#39;s chunked implementation
    {&#34;abcdefgh&#34;, &#34;abcdefgh&#34;, 0},
    {&#34;abcdefghi&#34;, &#34;abcdefghi&#34;, 0},
    {&#34;abcdefghi&#34;, &#34;abcdefghj&#34;, -1},
}

func TestCompare(t *testing.T) {
    for _, tt := range compareTests {
        cmp := Compare(tt.a, tt.b)
        if cmp != tt.i {
            t.Errorf(`Compare(%q, %q) = %v`, tt.a, tt.b, cmp)
        }
    }
}
</code></pre><p><strong>Note</strong>: The failure messages in this example above fulfill the guidance to <a href=https://google.github.io/styleguide/go/decisions#identify-the-function>identify the function</a> and <a href=https://google.github.io/styleguide/go/decisions#identify-the-input>identify the input</a>. There’s no need to <a href=https://google.github.io/styleguide/go/decisions#table-tests-identifying-the-row>identify the row numerically</a>.</p><p>When some test cases need to be checked using different logic from other test cases, it is more appropriate to write multiple test functions, as explained in <a href=https://google.github.io/styleguide/go/index.html#gotip>GoTip #50: Disjoint Table Tests</a>. The logic of your test code can get difficult to understand when each entry in a table has its own different conditional logic to check each output for its inputs. If test cases have different logic but identical setup, a sequence of <a href=https://google.github.io/styleguide/go/decisions#subtests>subtests</a> within a single test function might make sense.</p><p>You can combine table-driven tests with multiple test functions. For example, when testing that a function’s output exactly matches the expected output and that the function returns a non-nil error for an invalid input, then writing two separate table-driven test functions is the best approach: one for normal non-error outputs, and one for error outputs.</p><h4 id=data-driven-test-cases>Data-driven test cases
<a class=anchor href=#data-driven-test-cases>#</a></h4><p>Table test rows can sometimes become complicated, with the row values dictating conditional behavior inside the test case. The extra clarity from the duplication between the test cases is necessary for readability.</p><pre tabindex=0><code>// Good:
type decodeCase struct {
    name   string
    input  string
    output string
    err    error
}

func TestDecode(t *testing.T) {
    // setupCodex is slow as it creates a real Codex for the test.
    codex := setupCodex(t)

    var tests []decodeCase // rows omitted for brevity

    for _, test := range tests {
        t.Run(test.name, func(t *testing.T) {
            output, err := Decode(test.input, codex)
            if got, want := output, test.output; got != want {
                t.Errorf(&#34;Decode(%q) = %v, want %v&#34;, test.input, got, want)
            }
            if got, want := err, test.err; !cmp.Equal(got, want) {
                t.Errorf(&#34;Decode(%q) err %q, want %q&#34;, test.input, got, want)
            }
        })
    }
}

func TestDecodeWithFake(t *testing.T) {
    // A fakeCodex is a fast approximation of a real Codex.
    codex := newFakeCodex()

    var tests []decodeCase // rows omitted for brevity

    for _, test := range tests {
        t.Run(test.name, func(t *testing.T) {
            output, err := Decode(test.input, codex)
            if got, want := output, test.output; got != want {
                t.Errorf(&#34;Decode(%q) = %v, want %v&#34;, test.input, got, want)
            }
            if got, want := err, test.err; !cmp.Equal(got, want) {
                t.Errorf(&#34;Decode(%q) err %q, want %q&#34;, test.input, got, want)
            }
        })
    }
}
</code></pre><p>In the counterexample below, note how hard it is to distinguish between which type of <code>Codex</code> is used per test case in the case setup. (The highlighted parts run afoul of the advice from <a href=https://testing.googleblog.com/2008/09/tott-data-driven-traps.html>TotT: Data Driven Traps!</a> .)</p><pre tabindex=0><code>// Bad:
type decodeCase struct {
  name   string
  input  string
  codex  testCodex
  output string
  err    error
}

type testCodex int

const (
  fake testCodex = iota
  prod
)

func TestDecode(t *testing.T) {
  var tests []decodeCase // rows omitted for brevity

  for _, test := tests {
    t.Run(test.name, func(t *testing.T) {
      var codex Codex
      switch test.codex {
      case fake:
        codex = newFakeCodex()
      case prod:
        codex = setupCodex(t)
      default:
        t.Fatalf(&#34;unknown codex type: %v&#34;, codex)
      }
      output, err := Decode(test.input, codex)
      if got, want := output, test.output; got != want {
        t.Errorf(&#34;Decode(%q) = %q, want %q&#34;, test.input, got, want)
      }
      if got, want := err, test.err; !cmp.Equal(got, want) {
        t.Errorf(&#34;Decode(%q) err %q, want %q&#34;, test.input, got, want)
      }
    })
  }
}
</code></pre><h4 id=identifying-the-row>Identifying the row
<a class=anchor href=#identifying-the-row>#</a></h4><p>Do not use the index of the test in the test table as a substitute for naming your tests or printing the inputs. Nobody wants to go through your test table and count the entries in order to figure out which test case is failing.</p><pre tabindex=0><code>// Bad:
tests := []struct {
    input, want string
}{
    {&#34;hello&#34;, &#34;HELLO&#34;},
    {&#34;wORld&#34;, &#34;WORLD&#34;},
}
for i, d := range tests {
    if strings.ToUpper(d.input) != d.want {
        t.Errorf(&#34;failed on case #%d&#34;, i)
    }
}
</code></pre><p>Add a test description to your test struct and print it along failure messages. When using subtests, your subtest name should be effective in identifying the row.</p><p><strong>Important:</strong> Even though <code>t.Run</code> scopes the output and execution, you must always <a href=https://google.github.io/styleguide/go/decisions#identify-the-input>identify the input</a>. The table test row names must follow the <a href=https://google.github.io/styleguide/go/decisions#subtest-names>subtest naming</a> guidance.</p><h3 id=test-helpers>Test helpers
<a class=anchor href=#test-helpers>#</a></h3><p>A test helper is a function that performs a setup or cleanup task. All failures that occur in test helpers are expected to be failures of the environment (not from the code under test) — for example when a test database cannot be started because there are no more free ports on this machine.</p><p>If you pass a <code>*testing.T</code>, call <a href=https://pkg.go.dev/testing#T.Helper><code>t.Helper</code></a> to attribute failures in the test helper to the line where the helper is called. This parameter should come after a <a href=https://google.github.io/styleguide/go/decisions#contexts>context</a> parameter, if present, and before any remaining parameters.</p><pre tabindex=0><code>// Good:
func TestSomeFunction(t *testing.T) {
    golden := readFile(t, &#34;testdata/golden-result.txt&#34;)
    // ... tests against golden ...
}

// readFile returns the contents of a data file.
// It must only be called from the same goroutine as started the test.
func readFile(t *testing.T, filename string) string {
    t.Helper()
    contents, err := runfiles.ReadFile(filename)
    if err != nil {
        t.Fatal(err)
    }
    return string(contents)
}
</code></pre><p>Do not use this pattern when it obscures the connection between a test failure and the conditions that led to it. Specifically, the guidance about <a href=https://google.github.io/styleguide/go/decisions#assert>assert libraries</a> still applies, and <a href=https://pkg.go.dev/testing#T.Helper><code>t.Helper</code></a> should not be used to implement such libraries.</p><p><strong>Tip:</strong> For more on the distinction between test helpers and assertion helpers, see <a href=https://google.github.io/styleguide/go/best-practices#test-functions>best practices</a>.</p><p>Although the above refers to <code>*testing.T</code>, much of the advice stays the same for benchmark and fuzz helpers.</p><h3 id=test-package>Test package
<a class=anchor href=#test-package>#</a></h3><h4 id=tests-in-the-same-package>Tests in the same package
<a class=anchor href=#tests-in-the-same-package>#</a></h4><p>Tests may be defined in the same package as the code being tested.</p><p>To write a test in the same package:</p><ul><li>Place the tests in a <code>foo_test.go</code> file</li><li>Use <code>package foo</code> for the test file</li><li>Do not explicitly import the package to be tested</li></ul><pre tabindex=0><code class=language-build data-lang=build># Good:
go_library(
    name = &#34;foo&#34;,
    srcs = [&#34;foo.go&#34;],
    deps = [
        ...
    ],
)

go_test(
    name = &#34;foo_test&#34;,
    size = &#34;small&#34;,
    srcs = [&#34;foo_test.go&#34;],
    library = &#34;:foo&#34;,
    deps = [
        ...
    ],
)
</code></pre><p>A test in the same package can access unexported identifiers in the package. This may enable better test coverage and more concise tests. Be aware that any <a href=https://google.github.io/styleguide/go/decisions#examples>examples</a> declared in the test will not have the package names that a user will need in their code.</p><h4 id=tests-in-a-different-package>Tests in a different package
<a class=anchor href=#tests-in-a-different-package>#</a></h4><p>It is not always appropriate or even possible to define a test in the same package as the code being tested. In these cases, use a package name with the <code>_test</code> suffix. This is an exception to the “no underscores” rule to <a href=https://google.github.io/styleguide/go/decisions#package-names>package names</a>. For example:</p><ul><li><p>If an integration test does not have an obvious library that it belongs to</p><pre tabindex=0><code>// Good:
package gmailintegration_test

import &#34;testing&#34;
</code></pre></li><li><p>If defining the tests in the same package results in circular dependencies</p><pre tabindex=0><code>// Good:
package fireworks_test

import (
  &#34;fireworks&#34;
  &#34;fireworkstestutil&#34; // fireworkstestutil also imports fireworks
)
</code></pre></li></ul><h3 id=use-package-testing>Use package <code>testing</code>
<a class=anchor href=#use-package-testing>#</a></h3><p>The Go standard library provides the <a href=https://pkg.go.dev/testing><code>testing</code> package</a>. This is the only testing framework permitted for Go code in the Google codebase. In particular, <a href=https://google.github.io/styleguide/go/decisions#assert>assertion libraries</a> and third-party testing frameworks are not allowed.</p><p>The <code>testing</code> package provides a minimal but complete set of functionality for writing good tests:</p><ul><li>Top-level tests</li><li>Benchmarks</li><li><a href=https://blog.golang.org/examples>Runnable examples</a></li><li>Subtests</li><li>Logging</li><li>Failures and fatal failures</li></ul><p>These are designed to work cohesively with core language features like <a href=https://go.dev/ref/spec#Composite_literals>composite literal</a> and <a href=https://go.dev/ref/spec#If_statements>if-with-initializer</a> syntax to enable test authors to write [clear, readable, and maintainable tests].</p><h2 id=non-decisions>Non-decisions
<a class=anchor href=#non-decisions>#</a></h2><p>A style guide cannot enumerate positive prescriptions for all matters, nor can it enumerate all matters about which it does not offer an opinion. That said, here are a few things where the readability community has previously debated and has not achieved consensus about.</p><ul><li><strong>Local variable initialization with zero value</strong>. <code>var i int</code> and <code>i := 0</code> are equivalent. See also <a href=https://google.github.io/styleguide/go/best-practices#vardeclinitialization>initialization best practices</a>.</li><li><strong>Empty composite literal vs. <code>new</code> or <code>make</code></strong>. <code>&File{}</code> and <code>new(File)</code> are equivalent. So are <code>map[string]bool{}</code> and <code>make(map[string]bool)</code>. See also <a href=https://google.github.io/styleguide/go/best-practices#vardeclcomposite>composite declaration best practices</a>.</li><li><strong>got, want argument ordering in cmp.Diff calls</strong>. Be locally consistent, and <a href=https://google.github.io/styleguide/go/decisions#print-diffs>include a legend</a> in your failure message.</li><li><strong><code>errors.New</code> vs <code>fmt.Errorf</code> on non-formatted strings</strong>. <code>errors.New("foo")</code> and <code>fmt.Errorf("foo")</code> may be used interchangeably.</li></ul><p>If there are special circumstances where they come up again, the readability mentor might make an optional comment, but in general the author is free to pick the style they prefer in the given situation.</p><p>Naturally, if anything not covered by the style guide does need more discussion, authors are welcome to ask – either in the specific review, or on internal message boards.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#关于>关于</a></li><li><a href=#命名naming>命名Naming</a><ul><li><a href=#下划线underscores>下划线Underscores</a></li><li><a href=#包名称package-names>包名称Package names</a></li><li><a href=#接收者命名receiver-names>接收者命名Receiver names</a></li><li><a href=#常量命名constant-names>常量命名Constant names</a></li><li><a href=#缩写词initialisms>缩写词Initialisms</a></li><li><a href=#get方法getters>Get方法Getters</a></li><li><a href=#变量名variable-names>变量名Variable names</a></li><li><a href=#重复repetition>重复Repetition</a></li></ul></li><li><a href=#评论commentary>评论Commentary</a><ul><li><a href=#注释行长度comment-line-length>注释行长度Comment line length</a></li><li><a href=#文档注释doc-comments>文档注释Doc comments</a></li><li><a href=#注释语句comment-sentences>注释语句Comment sentences</a></li><li><a href=#示例examples>示例Examples</a></li><li><a href=#命名的结果参数named-result-parameters>命名的结果参数Named result parameters</a></li><li><a href=#包注释>包注释</a></li></ul></li><li><a href=#导入>导入</a><ul><li><a href=#导入重命名>导入重命名</a></li><li><a href=#导入分组>导入分组</a></li><li><a href=#导入空-import-_>导入"空" (<code>import _</code>)</a></li><li><a href=#导入--import->导入 “.” (<code>import .</code>)</a></li></ul></li><li><a href=#错误>错误</a><ul><li><a href=#返回错误>返回错误</a></li><li><a href=#错误字符串>错误字符串</a></li><li><a href=#错误处理>错误处理</a></li><li><a href=#in-band-错误>In-band 错误</a></li><li><a href=#缩进错误流程>缩进错误流程</a></li></ul></li><li><a href=#语言>语言</a><ul><li><a href=#字面格式化>字面格式化</a></li><li><a href=#nil-切片>Nil 切片</a></li><li><a href=#缩进的混乱>缩进的混乱</a></li><li><a href=#函数格式化>函数格式化</a></li><li><a href=#条件和循环>条件和循环</a></li><li><a href=#复制>复制</a></li><li><a href=#不要-panic>不要 panic</a></li><li><a href=#must类函数>Must类函数</a></li><li><a href=#goroutine-生命周期>Goroutine 生命周期</a></li><li><a href=#接口>接口</a></li><li><a href=#泛型>泛型</a></li><li><a href=#参数值传递>参数值传递</a></li><li><a href=#接收者类型>接收者类型</a></li><li><a href=#switch-和-break><code>switch</code> 和 <code>break</code></a></li><li><a href=#同步函数>同步函数</a></li><li><a href=#类型别名>类型别名</a></li><li><a href=#使用-q>使用 %q</a></li><li><a href=#使用-any>使用 any</a></li></ul></li><li><a href=#通用库>通用库</a><ul><li><a href=#flags>Flags</a></li><li><a href=#日志>日志</a></li><li><a href=#上下文>上下文</a></li><li><a href=#cryptorand>crypto/rand</a></li></ul></li><li><a href=#有用的测试失败>有用的测试失败</a><ul><li><a href=#断言库>断言库</a></li><li><a href=#标识出方法>标识出方法</a></li><li><a href=#标识出输入>标识出输入</a></li><li><a href=#got-before-want>Got before want</a></li><li><a href=#全结构比较>全结构比较</a></li><li><a href=#compare-stable-results>Compare stable results</a></li><li><a href=#keep-going>Keep going</a></li><li><a href=#equality-comparison-and-diffs>Equality comparison and diffs</a></li><li><a href=#level-of-detail>Level of detail</a></li><li><a href=#print-diffs>Print diffs</a></li><li><a href=#test-error-semantics>Test error semantics</a></li></ul></li><li><a href=#test-structure>Test structure</a><ul><li><a href=#subtests>Subtests</a></li><li><a href=#table-driven-tests>Table-driven tests</a></li><li><a href=#test-helpers>Test helpers</a></li><li><a href=#test-package>Test package</a></li><li><a href=#use-package-testing>Use package <code>testing</code></a></li></ul></li><li><a href=#non-decisions>Non-decisions</a></li></ul></nav></div></aside></main></body></html>