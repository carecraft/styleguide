<!doctype html><html lang=zh dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Go Style Guide # Style principles # There are a few overarching principles that summarize how to think about writing readable Go code. The following are attributes of readable code, in order of importance:
Clarity: The code’s purpose and rationale is clear to the reader. Simplicity: The code accomplishes its goal in the simplest way possible. Concision: The code has a high signal-to-noise ratio. Maintainability: The code is written such that it can be easily maintained."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content><meta property="og:description" content="Go Style Guide # Style principles # There are a few overarching principles that summarize how to think about writing readable Go code. The following are attributes of readable code, in order of importance:
Clarity: The code’s purpose and rationale is clear to the reader. Simplicity: The code accomplishes its goal in the simplest way possible. Concision: The code has a high signal-to-noise ratio. Maintainability: The code is written such that it can be easily maintained."><meta property="og:type" content="article"><meta property="og:url" content="https://gocn.github.io/styleguide/docs/02-guide/"><meta property="article:section" content="docs"><title>02 Guide | Google Style Guides</title><link rel=manifest href=/styleguide/manifest.json><link rel=icon href=/styleguide/favicon.png type=image/x-icon><link rel=stylesheet href=/styleguide/book.min.c58292d36b18b675680ab9baea2029204537b839ea72f258746ec0f32ce8d6c8.css integrity="sha256-xYKS02sYtnVoCrm66iApIEU3uDnqcvJYdG7A8yzo1sg=" crossorigin=anonymous><script defer src=/styleguide/flexsearch.min.js></script>
<script defer src=/styleguide/zh.search.min.7fc1bd3c3e71b3f69a656a03263df9709561dd5a24f4813a312958eef62d6463.js integrity="sha256-f8G9PD5xs/aaZWoDJj35cJVh3Vok9IE6MSlY7vYtZGM=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/styleguide/><span>Google Style Guides</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><p><strong>开始学习</strong></p><ul><li><a href=/styleguide/docs/01-overview/>1. Overview</a></li><li><a href=/styleguide/docs/02-guide/ class=active>2. Guide</a></li></ul></li><li><p><strong>附录：资源</strong></p></li><li><p><a href=https://github.com/gocn/styleguide><strong>Fork on Github</strong></a></p></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/styleguide/svg/menu.svg class=book-icon alt=Menu></label>
<strong>02 Guide</strong>
<label for=toc-control><img src=/styleguide/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#style-principles>Style principles</a><ul><li><a href=#clarity>Clarity</a></li><li><a href=#simplicity>Simplicity</a></li><li><a href=#concision>Concision</a></li><li><a href=#maintainability>Maintainability</a></li><li><a href=#consistency>Consistency</a></li></ul></li><li><a href=#core-guidelines>Core guidelines</a><ul><li><a href=#formatting>Formatting</a></li><li><a href=#mixedcaps>MixedCaps</a></li><li><a href=#line-length>Line length</a></li><li><a href=#naming>Naming</a></li><li><a href=#local-consistency>Local consistency</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=go-style-guide>Go Style Guide
<a class=anchor href=#go-style-guide>#</a></h1><h2 id=style-principles>Style principles
<a class=anchor href=#style-principles>#</a></h2><p>There are a few overarching principles that summarize how to think about writing readable Go code. The following are attributes of readable code, in order of importance:</p><ol><li><a href=https://google.github.io/styleguide/go/guide#clarity>Clarity</a>: The code’s purpose and rationale is clear to the reader.</li><li><a href=https://google.github.io/styleguide/go/guide#simplicity>Simplicity</a>: The code accomplishes its goal in the simplest way possible.</li><li><a href=https://google.github.io/styleguide/go/guide#concision>Concision</a>: The code has a high signal-to-noise ratio.</li><li><a href=https://google.github.io/styleguide/go/guide#maintainability>Maintainability</a>: The code is written such that it can be easily maintained.</li><li><a href=https://google.github.io/styleguide/go/guide#consistency>Consistency</a>: The code is consistent with the broader Google codebase.</li></ol><h3 id=clarity>Clarity
<a class=anchor href=#clarity>#</a></h3><p>The core goal of readability is to produce code that is clear to the reader.</p><p>Clarity is primarily achieved with effective naming, helpful commentary, and efficient code organization.</p><p>Clarity is to be viewed through the lens of the reader, not the author of the code. It is more important that code be easy to read than easy to write. Clarity in code has two distinct facets:</p><ul><li><a href=https://google.github.io/styleguide/go/guide#clarity-purpose>What is the code actually doing?</a></li><li><a href=https://google.github.io/styleguide/go/guide#clarity-rationale>Why is the code doing what it does?</a></li></ul><h4 id=what-is-the-code-actually-doing>What is the code actually doing?
<a class=anchor href=#what-is-the-code-actually-doing>#</a></h4><p>Go is designed such that it should be relatively straightforward to see what the code is doing. In cases of uncertainty or where a reader may require prior knowledge in order to understand the code, it is worth investing time in order to make the code’s purpose clearer for future readers. For example, it may help to:</p><ul><li>Use more descriptive variable names</li><li>Add additional commentary</li><li>Break up the code with whitespace and comments</li><li>Refactor the code into separate functions/methods to make it more modular</li></ul><p>There is no one-size-fits-all approach here, but it is important to prioritize clarity when developing Go code.</p><h4 id=why-is-the-code-doing-what-it-does>Why is the code doing what it does?
<a class=anchor href=#why-is-the-code-doing-what-it-does>#</a></h4><p>The code’s rationale is often sufficiently communicated by the names of variables, functions, methods, or packages. Where it is not, it is important to add commentary. The “Why?” is especially important when the code contains nuances that a reader may not be familiar with, such as:</p><ul><li>A nuance in the language, e.g., a closure will be capturing a loop variable, but the closure is many lines away</li><li>A nuance of the business logic, e.g., an access control check that needs to distinguish between the actual user and someone impersonating a user</li></ul><p>An API might require care to use correctly. For example, a piece of code may be intricate and difficult to follow for performance reasons, or a complex sequence of mathematical operations may use type conversions in an unexpected way. In these cases and many more, it is important that accompanying commentary and documentation explain these aspects so that future maintainers don’t make a mistake and so that readers can understand the code without needing to reverse-engineer it.</p><p>It is also important to be aware that some attempts to provide clarity (such as adding extra commentary) can actually obscure the code’s purpose by adding clutter, restating what the code already says, contradicting the code, or adding maintenance burden to keep the comments up-to-date. Allow the code to speak for itself (e.g., by making the symbol names themselves self-describing) rather than adding redundant comments. It is often better for comments to explain why something is done, not what the code is doing.</p><p>The Google codebase is largely uniform and consistent. It is often the case that code that stands out (e.g., by using an unfamiliar pattern) is doing so for a good reason, typically for performance. Maintaining this property is important to make it clear to readers where they should focus their attention when reading a new piece of code.</p><p>The standard library contains many examples of this principle in action. Among them:</p><ul><li>Maintainer comments in <code>package sort</code>.</li><li>Good <a href=https://cs.opensource.google/go/go/+/refs/tags/go1.19.2:src/sort/example_search_test.go>runnable examples in the same package</a>, which benefit both users (they <a href=https://pkg.go.dev/sort#pkg-examples>show up in godoc</a>) and maintainers (they <a href=https://google.github.io/styleguide/go/decisions#examples>run as part of tests</a>).</li><li><code>strings.Cut</code> is only four lines of code, but they improve the <a href=https://github.com/golang/go/issues/46336>clarity and correctness of callsites</a>.</li></ul><h3 id=simplicity>Simplicity
<a class=anchor href=#simplicity>#</a></h3><p>Your Go code should be simple for those using, reading, and maintaining it.</p><p>Go code should be written in the simplest way that accomplishes its goals, both in terms of behavior and performance. Within the Google Go codebase, simple code:</p><ul><li>Is easy to read from top to bottom</li><li>Does not assume that you already know what it is doing</li><li>Does not assume that you can memorize all of the preceding code</li><li>Does not have unnecessary levels of abstraction</li><li>Does not have names that call attention to something mundane</li><li>Makes the propagation of values and decisions clear to the reader</li><li>Has comments that explain why, not what, the code is doing to avoid future deviation</li><li>Has documentation that stands on its own</li><li>Has useful errors and useful test failures</li><li>May often be mutually exclusive with “clever” code</li></ul><p>Tradeoffs can arise between code simplicity and API usage simplicity. For example, it may be worthwhile to have the code be more complex so that the end user of the API may more easily call the API correctly. In contrast, it may also be worthwhile to leave a bit of extra work to the end user of the API so that the code remains simple and easy to understand.</p><p>When code needs complexity, the complexity should be added deliberately. This is typically necessary if additional performance is required or where there are multiple disparate customers of a particular library or service. Complexity may be justified, but it should come with accompanying documentation so that clients and future maintainers are able to understand and navigate the complexity. This should be supplemented with tests and examples that demonstrate its correct usage, especially if there is both a “simple” and a “complex” way to use the code.</p><p>This principle does not imply that complex code cannot or should not be written in Go or that Go code is not allowed to be complex. We strive for a codebase that avoids unnecessary complexity so that when complexity does appear, it indicates that the code in question requires care to understand and maintain. Ideally, there should be accompanying commentary that explains the rationale and identifies the care that should be taken. This often arises when optimizing code for performance; doing so often requires a more complex approach, like preallocating a buffer and reusing it throughout a goroutine lifetime. When a maintainer sees this, it should be a clue that the code in question is performance-critical, and that should influence the care that is taken when making future changes. If employed unnecessarily, on the other hand, this complexity is a burden on those who need to read or change the code in the future.</p><p>If code turns out to be very complex when its purpose should be simple, this is often a signal to revisit the implementation to see if there is a simpler way to accomplish the same thing.</p><h4 id=least-mechanism>Least mechanism
<a class=anchor href=#least-mechanism>#</a></h4><p>Where there are several ways to express the same idea, prefer the one that uses the most standard tools. Sophisticated machinery often exists, but should not be employed without reason. It is easy to add complexity to code as needed, whereas it is much harder to remove existing complexity after it has been found to be unnecessary.</p><ol><li>Aim to use a core language construct (for example a channel, slice, map, loop, or struct) when sufficient for your use case.</li><li>If there isn’t one, look for a tool within the standard library (like an HTTP client or a template engine).</li><li>Finally, consider whether there is a core library in the Google codebase that is sufficient before introducing a new dependency or creating your own.</li></ol><p>As an example, consider production code that contains a flag bound to a variable with a default value which must be overridden in tests. Unless intending to test the program’s command-line interface itself (say, with <code>os/exec</code>), it is simpler and therefore preferable to override the bound value directly rather than by using flag.Set.</p><p>Similarly, if a piece of code requires a set membership check, a boolean-valued map (e.g., <code>map[string]bool</code>) often suffices. Libraries that provide set-like types and functionality should only be used if more complicated operations are required that are impossible or overly complicated with a map.</p><h3 id=concision>Concision
<a class=anchor href=#concision>#</a></h3><p>Concise Go code has a high signal-to-noise ratio. It is easy to discern the relevant details, and the naming and structure guide the reader through these details.</p><p>There are many things that can get in the way of surfacing the most salient details at any given time:</p><ul><li>Repetitive code</li><li>Extraneous syntax</li><li><a href=https://google.github.io/styleguide/go/guide#naming>Opaque names</a></li><li>Unnecessary abstraction</li><li>Whitespace</li></ul><p>Repetitive code especially obscures the differences between each nearly-identical section, and requires a reader to visually compare similar lines of code to find the changes. <a href=https://github.com/golang/go/wiki/TableDrivenTests>Table-driven testing</a> is a good example of a mechanism that can concisely factor out the common code from the important details of each repetition, but the choice of which pieces to include in the table will have an impact on how easy the table is to understand.</p><p>When considering multiple ways to structure code, it is worth considering which way makes important details the most apparent.</p><p>Understanding and using common code constructions and idioms are also important for maintaining a high signal-to-noise ratio. For example, the following code block is very common in <a href=https://go.dev/blog/errors-are-values>error handling</a>, and the reader can quickly understand the purpose of this block.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Good:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>doSomething</span>(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>If code looks very similar to this but is subtly different, a reader may not notice the change. In cases like this, it is worth intentionally <a href=https://google.github.io/styleguide/go/best-practices#signal-boost>“boosting”</a> the signal of the error check by adding a comment to call attention to it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Good:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>doSomething</span>(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> { <span style=color:#75715e>// if NO error
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h3 id=maintainability>Maintainability
<a class=anchor href=#maintainability>#</a></h3><p>Code is edited many more times than it is written. Readable code not only makes sense to a reader who is trying to understand how it works, but also to the programmer who needs to change it. Clarity is key.</p><p>Maintainable code:</p><ul><li>Is easy for a future programmer to modify correctly</li><li>Has APIs that are structured so that they can grow gracefully</li><li>Is clear about the assumptions that it makes and chooses abstractions that map to the structure of the problem, not to the structure of the code</li><li>Avoids unnecessary coupling and doesn’t include features that are not used</li><li>Has a comprehensive test suite to ensure promised behaviors are maintained and important logic is correct, and the tests provide clear, actionable diagnostics in case of failure</li></ul><p>When using abstractions like interfaces and types which by definition remove information from the context in which they are used, it is important to ensure that they provide sufficient benefit. Editors and IDEs can connect directly to a method definition and show the corresponding documentation when a concrete type is used, but can only refer to an interface definition otherwise. Interfaces are a powerful tool, but come with a cost, since the maintainer may need to understand the specifics of the underlying implementation in order to correctly use the interface, which must be explained within the interface documentation or at the call-site.</p><p>Maintainable code also avoids hiding important details in places that are easy to overlook. For example, in each of the following lines of code, the presence or lack of a single character is critical to understand the line:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Bad:
</span></span></span><span style=display:flex><span><span style=color:#75715e>// The use of = instead of := can change this line completely.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>user</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>UserByID</span>(<span style=color:#a6e22e>userID</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Bad:
</span></span></span><span style=display:flex><span><span style=color:#75715e>// The ! in the middle of this line is very easy to miss.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>leap</span> <span style=color:#f92672>:=</span> (<span style=color:#a6e22e>year</span><span style=color:#f92672>%</span><span style=color:#ae81ff>4</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) <span style=color:#f92672>&amp;&amp;</span> (!(<span style=color:#a6e22e>year</span><span style=color:#f92672>%</span><span style=color:#ae81ff>100</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) <span style=color:#f92672>||</span> (<span style=color:#a6e22e>year</span><span style=color:#f92672>%</span><span style=color:#ae81ff>400</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>))
</span></span></code></pre></div><p>Neither of these are incorrect, but both could be written in a more explicit fashion, or could have an accompanying comment that calls attention to the important behavior:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Good:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>u</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>UserByID</span>(<span style=color:#a6e22e>userID</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;invalid origin user: %s&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>user</span> = <span style=color:#a6e22e>u</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Good:
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Gregorian leap years aren&#39;t just year%4 == 0.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// See https://en.wikipedia.org/wiki/Leap_year#Algorithm.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> (
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>leap4</span>   = <span style=color:#a6e22e>year</span><span style=color:#f92672>%</span><span style=color:#ae81ff>4</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>leap100</span> = <span style=color:#a6e22e>year</span><span style=color:#f92672>%</span><span style=color:#ae81ff>100</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>leap400</span> = <span style=color:#a6e22e>year</span><span style=color:#f92672>%</span><span style=color:#ae81ff>400</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>leap</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>leap4</span> <span style=color:#f92672>&amp;&amp;</span> (!<span style=color:#a6e22e>leap100</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>leap400</span>)
</span></span></code></pre></div><p>In the same way, a helper function that hides critical logic or an important edge-case could make it easy for a future change to fail to account for it properly.</p><p>Predictable names are another feature of maintainable code. A user of a package or a maintainer of a piece of code should be able to predict the name of a variable, method, or function in a given context. Function parameters and receiver names for identical concepts should typically share the same name, both to keep documentation understandable and to facilitate refactoring code with minimal overhead.</p><p>Maintainable code minimizes its dependencies (both implicit and explicit). Depending on fewer packages means fewer lines of code that can affect behavior. Avoiding dependencies on internal or undocumented behavior makes code less likely to impose a maintenance burden when those behaviors change in the future.</p><p>When considering how to structure or write code, it is worth taking the time to think through ways in which the code may evolve over time. If a given approach is more conducive to easier and safer future changes, that is often a good trade-off, even if it means a slightly more complicated design.</p><h3 id=consistency>Consistency
<a class=anchor href=#consistency>#</a></h3><p>Consistent code is code that looks, feels, and behaves like similar code throughout the broader codebase, within the context of a team or package, and even within a single file.</p><p>Consistency concerns do not override any of the principles above, but if a tie must be broken, it is often beneficial to break it in favor of consistency.</p><p>Consistency within a package is often the most immediately important level of consistency. It can be very jarring if the same problem is approached in multiple ways throughout a package, or if the same concept has many names within a file. However, even this should not override documented style principles or global consistency.</p><h2 id=core-guidelines>Core guidelines
<a class=anchor href=#core-guidelines>#</a></h2><p>These guidelines collect the most important aspects of Go style that all Go code is expected to follow. We expect that these principles be learned and followed by the time readability is granted. These are not expected to change frequently, and new additions will have to clear a high bar.</p><p>The guidelines below expand on the recommendations in <a href=https://go.dev/doc/effective_go>Effective Go</a>, which provide a common baseline for Go code across the entire community.</p><h3 id=formatting>Formatting
<a class=anchor href=#formatting>#</a></h3><p>All Go source files must conform to the format outputted by the gofmt tool. This format is enforced by a presubmit check in the Google codebase. <a href=https://docs.bazel.build/versions/main/be/general.html#genrule>Generated code</a> should generally also be formatted (e.g., by using <code>format.Source</code>), as it is also browsable in Code Search.</p><h3 id=mixedcaps>MixedCaps
<a class=anchor href=#mixedcaps>#</a></h3><p>Go source code uses <code>MixedCaps</code> or <code>mixedCaps</code> (camel case) rather than underscores (snake case) when writing multi-word names.</p><p>This applies even when it breaks conventions in other languages. For example, a constant is <code>MaxLength</code> (not <code>MAX_LENGTH</code>) if exported and <code>maxLength</code> (not <code>max_length</code>) if unexported.</p><p>Local variables are considered <a href=https://go.dev/ref/spec#Exported_identifiers>unexported</a> for the purpose of choosing the initial capitalization.</p><h3 id=line-length>Line length
<a class=anchor href=#line-length>#</a></h3><p>There is no fixed line length for Go source code. If a line feels too long, it should be refactored instead of broken. If it is already as short as it is practical for it to be, the line should be allowed to remain long.</p><p>Do not split a line:</p><ul><li>Before an <a href=https://google.github.io/styleguide/go/decisions#indentation-confusion>indentation change</a> (e.g., function declaration, conditional)</li><li>To make a long string (e.g., a URL) fit into multiple shorter lines</li></ul><h3 id=naming>Naming
<a class=anchor href=#naming>#</a></h3><p>Naming is more art than science. In Go, names tend to be somewhat shorter than in many other languages, but the same <a href=https://testing.googleblog.com/2017/10/code-health-identifiernamingpostforworl.html>general guidelines</a> apply. Names should:</p><ul><li>Not feel <a href=https://google.github.io/styleguide/go/decisions#repetition>repetitive</a> when they are used</li><li>Take the context into consideration</li><li>Not repeat concepts that are already clear</li></ul><p>You can find more specific guidance on naming in <a href=https://google.github.io/styleguide/go/decisions#naming>decisions</a>.</p><h3 id=local-consistency>Local consistency
<a class=anchor href=#local-consistency>#</a></h3><p>Where the style guide has nothing to say about a particular point of style, authors are free to choose the style that they prefer, unless the code in close proximity (usually within the same file or package, but sometimes within a team or project directory) has taken a consistent stance on the issue.</p><p>Examples of <strong>valid</strong> local style considerations:</p><ul><li>Use of <code>%s</code> or <code>%v</code> for formatted printing of errors</li><li>Usage of buffered channels in lieu of mutexes</li></ul><p>Examples of <strong>invalid</strong> local style considerations:</p><ul><li>Line length restrictions for code</li><li>Use of assertion-based testing libraries</li></ul><p>If the local style disagrees with the style guide but the readability impact is limited to one file, it will generally be surfaced in a code review for which a consistent fix would be outside the scope of the CL in question. At that point, it is appropriate to file a bug to track the fix.</p><p>If a change would worsen an existing style deviation, expose it in more API surfaces, expand the number of files in which the deviation is present, or introduce an actual bug, then local consistency is no longer a valid justification for violating the style guide for new code. In these cases, it is appropriate for the author to clean up the existing codebase in the same CL, perform a refactor in advance of the current CL, or find an alternative that at least does not make the local problem worse.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#style-principles>Style principles</a><ul><li><a href=#clarity>Clarity</a></li><li><a href=#simplicity>Simplicity</a></li><li><a href=#concision>Concision</a></li><li><a href=#maintainability>Maintainability</a></li><li><a href=#consistency>Consistency</a></li></ul></li><li><a href=#core-guidelines>Core guidelines</a><ul><li><a href=#formatting>Formatting</a></li><li><a href=#mixedcaps>MixedCaps</a></li><li><a href=#line-length>Line length</a></li><li><a href=#naming>Naming</a></li><li><a href=#local-consistency>Local consistency</a></li></ul></li></ul></nav></div></aside></main></body></html>